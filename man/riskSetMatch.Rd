% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/riskSetMatch.R
\name{riskSetMatch}
\alias{riskSetMatch}
\title{riskSetMatch - Risk set matching}
\usage{
riskSetMatch(ptid,event,terms,dat,Ncontrols,oldevent="oldevent",caseid="caseid",
  reuseCases=FALSE,reuseControls=FALSE,caseIndex=NULL,controlIndex=NULL,NoIndex=FALSE,cores=1)
}
\arguments{
\item{ptid}{Personal ID variable defining participant}

\item{event}{Defining cases/controls MUST be 0/1 - 0 for controls, 1 for case}

\item{terms}{c(.....) Specifies the variables that should be matched by - enclosed in ".."}

\item{dat}{The single dataset with all information - must be data.table}

\item{Ncontrols}{Number of controls sought for each case}

\item{oldevent}{Holds original value of event - distinguishes cases used as controls}

\item{caseid}{- variable holding grouping variable for cases/controls (=case-ptid)}

\item{reuseCases}{Logical. If \code{TRUE} a case can be a control prior to being a case}

\item{reuseControls}{Logical. If \code{TRUE} a control can be reused for several cases}

\item{caseIndex}{Date variable defining the date where a case becomes a case. For a case control study this
is the date of event of interest, for a cohort study the date where a case enters an analysis}

\item{controlIndex}{date variable defining the date from which a controls can no longer be selected.  The controlIndex
must be larger than the caseIndex.  For a case control study this would be the date where a control has the 
event of interest or is censored.  For a cohort study it would be the date where the control disappears from 
the analysis, e.g. due to death or censoring.}

\item{NoIndex}{Logical. If \code{TRUE} caseIndex/controlIndex are ignored}

\item{cores}{number of cores to use, default is one}
}
\value{
data.table with cases and controls. After matching, a new variable "caseid" links controls to cases.
Further, a variable "oldevent" holds the orginal value of "event" - to be used to identify cases functioning
as controls prior to being cases.
Variables in the original dataset are preserved. The final dataset includes all original cases but only the 
controls that were selected.
}
\description{
Risk set matching - also termed incidence density sampling - matches cases to control in such a way that only 
controls with event later than the case are accepted.  The current program is based on exact matching and allows 
the user to specify a "greedy" approach where controls are only used once as well as allowing the program to
reuse controls and to allow cases to be controls prior to being a case.
}
\details{
The function does exact matching and keeps 2 dates (indices) apart such that the date for controls is larger than 
that for cases. Because the matching is exact all matching variables must be integer or character. Make sure that
sufficient rounding is done on continuous and semicontinuous variables to ensure a decent number of controls for 
each case. For example it may be difficult to find controls for cases of very high age and age should therefore
often be rounded by 2,3 or 5 years - and extreme ages further aggregated.

For case control studies age may be a relevant matching parameter - for most cohort studies year of birth is
more relevant since the age of a control varies with time.

For many purposes controls should be reused and cases allowed to be controls prior to being cases. By default,
there is no reuse and this can be adjusted with "reuseCases" and "reuseControls"

The function can be used for standard matching without the caseIndex/controlIndex (with "NoIndex"), but other packages
such as MatchIt are more likely to be optimal for these cases.

It may appear tempting always to use multiple cores, but this comes with a costly overhead because the function
machinery has to be distributed to each defined "worker".  With very large numbers of cases and controls, multiple
cores can save substantial amounts of time. When a single core is used a progress shows progress of matching. 
There is no progress bar with multiple cores

The function matchReport may afterwards be used to provide simple summaries of use of cases and controls
}
\examples{
require(data.table)
case <- c(rep(0,40),rep(1,15)) 
ptid <- paste0("P",1:55)
sex <- c(rep("fem",20),rep("mal",20),rep("fem",8),rep("mal",7))
byear <- c(rep(c(2020,2030),20),rep(2020,7),rep(2030,8))
case.Index <- c(seq(1,40,1),seq(5,47,3))
control.Index <- case.Index
library(data.table)
dat <- data.table(ptid,case,sex,byear,case.Index,control.Index)
# Very simple match without reuse - no dates to control for
out <- riskSetMatch("ptid","case",c("byear","sex"),dat,2,NoIndex=TRUE)
out[]
# Risk set matching without reusing cases/controls - Some cases have no controls
out2 <- riskSetMatch("ptid","case",c("byear","sex"),dat,2,caseIndex="case.Index",
  controlIndex="control.Index")
out2[]   
# Risk set matching with reuse of cases (control prior to case) and reuse of 
# controls - more cases get controls
out3 <- riskSetMatch("ptid","case",c("byear","sex"),dat,2,caseIndex=
  "case.Index",controlIndex="control.Index"
  ,reuseCases=TRUE,reuseControls=TRUE)
out3[]   
# Same with 2 cores
out4 <- riskSetMatch("ptid","case",c("byear","sex"),dat,2,caseIndex=
  "case.Index",controlIndex="control.Index"
  ,reuseCases=TRUE,reuseControls=TRUE,cores=2)  
out4[]           
}
\seealso{
matchReport Matchit
}
\author{
Christian Torp-Pedersen
}
