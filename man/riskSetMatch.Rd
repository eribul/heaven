% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/riskSetMatch.R
\name{riskSetMatch}
\alias{riskSetMatch}
\title{riskSetMatch - Risk set matching}
\usage{
riskSetMatch(ptid,event,terms,data,n.controls,
   ,case.id="case.id",case.index=NULL
   ,end.followup=NULL,cores=1,date.terms=NULL,
   exposure.window=0,start.date=NULL,seed=17)
}
\arguments{
\item{ptid}{Personal ID variable defining participant}

\item{event}{Defining cases/controls MUST be integer 0/1 - 0 for controls, 1 for case}

\item{terms}{Vector of variable names specifying the variables that should be matched on.}

\item{data}{The single dataset with all information - coerced to data.table
if data.frame}

\item{n.controls}{Number of controls for each case}

\item{case.id}{Character. Variable holding grouping variable for
cases/controls (=case-ptid)}

\item{case.index}{Integer or Date. Date variable defining the date where a case
becomes a case. For a case control study this is the date of event of
interest, for a cohort study the date where a case enters an analysis.}

\item{end.followup}{Integer or Date. Date variable defining the date from which
a controls can no longer be selected. The end.followup must be larger or equal to 
the case.index date. The date where the control disappears from the analysis, e.g. due to
death, other competing risk, or censoring.}

\item{cores}{number of cores to use in the calculation.}

\item{date.terms}{c(....) A list of variable neames (character) in "data"
specifying dates of conditions. When a list is specified it is not only
checked that the case.index is not after end.followup, but also that for all
variables in the list either both control/case dates are missing, both prior
to case index, both after case index - or missing for case and with control
date after case index.}

\item{exposure.window}{For case/control studies this can be specified to
ensure that controls have a minimum expore window for some condition which
starts at the following variable "start.date".  For practical use only cases
with a certain exposure window are first selected and then this feature is
used to ensure similar exposure for controls.}

\item{start.date}{Starting date of condition which defines exposure window}

\item{seed}{- Seed for random shuffling of cases}

\item{progressbar}{set to \code{FALSE} to avoid progressbar}
}
\value{
data.table with cases and controls. After matching, a the variable
"case.id" identifies sets which include 1 case and x matched controls.

Variables in the original dataset are preserved. The final dataset includes
all original cases but only the controls that were selected.
}
\description{
Risk set matching or incidence density sampling: Within a cohort,
every time a case is diagnosed (has event) one or more controls are selected
from other members of the cohort who are at risk at that time, i.e.,
do not have the diagnosis at that time. In addition to selecting controls from
the risk set of the case, the function can use exact matching on the
covariates values at the case's diagnosis date. In particular, the function can
match on the status of other diagnoses (other events) at the case's index date. 

The resulting dataset can be used to fit a Cox regression model
with time-dependent covariates.  

To provide necessary speed for large samples the general technique used is
work with data.table and to create a series of match groups that have the fixed matching variables
identical (such as birthyear and gender).
}
\details{
The function performs exact matching and hence 
all matching variables must be factor variables or character.

Make sure that
appropriate classification is in place for truly continuous variables, such as age. This is to
ensure a sufficient number of controls for each case. For example it may be
difficult to find controls for cases of very high and very low ages
and extreme ages should therefor further aggregated. 

Many datasets have comorbidities as time dependent variables. Matching on
these requires that the comorbidity date is not (yet) reached for a corres-
ponding variables for cases if the case does not have the comorbidity and
similarly that the date has been reached when the case does have that co-
morbidity. 

For special cases it may be required that there is a minimum duration of a
condition shared by cases and controls. This can be achieved with defining
exposure window (same units as the various times, usually days) and
start.date, the day the condition of interest starts

It may appear tempting always to use multiple cores, but this comes with a
time costing overhead because the function machinery has to be distributed
to each defined "worker".  With very large numbers of cases and controls,
multiple cores can save substantial amounts of time. When a single core is
used a progress shows progress of matching. There is no progress bar with
multiple cores.

The function matchReport may afterwards be used to provide simple summaries
of use of cases and controls
}
\examples{
require(data.table)
case <- c(rep(0,40),rep(1,15))
ptid <- paste0("P",1:55)
sex <- c(rep("fem",20),rep("mal",20),rep("fem",8),rep("mal",7))
byear <- c(rep(c(2020,2030),20),rep(2020,7),rep(2030,8))
case.Index <- c(seq(1,40,1),seq(5,47,3))
startDisease <- rep(10,55)
control.Index <- case.Index
diabetes <- seq(2,110,2)
heartdis <- seq(110,2,-2)
diabetes <- c(rep(1,55))
heartdis <- c(rep(100,55))
library(data.table)
dat <- data.table(case,ptid,sex,byear,diabetes,heartdis,case.Index,
control.Index,startDisease)
# Risk set matching
out3 <- riskSetMatch("ptid","case",c("byear","sex"),data=dat,2,case.index=
  "case.Index",end.followup="control.Index")
out3[]
# Same with 2 cores
library(parallel)
library(foreach)
out4 <- riskSetMatch("ptid","case",c("byear","sex"),data=dat,2,case.index=
  "case.Index",end.followup="control.Index"
  ,cores=2)
out4[]
#Time dependent matching. In addtion to fixed matching parameters there are
#two other sets of dates where it is required that if a case has that condi-
#tion prior to index, then controls also need to have the condition prior to
#the case index to be eligible - and if the control does not have the condi-
#tion prior to index then the same is required for the control.
out5 <- riskSetMatch("ptid","case",c("byear","sex"),data=dat,2,case.index=
  "case.Index",end.followup="control.Index"
  ,cores=1,
  date.terms=c("diabetes","heartdis"))
out5[]
# Case control matching with requirement of minimum exposure time in each
# group
out6 <- riskSetMatch("ptid","case",c("byear","sex"),data=dat,2,case.index=
  "case.Index",end.followup="control.Index"
  ,cores=1,
  exposure.window=15,start.date="startDisease")
out6[]

#POSTPROCESSING
#It may be convinient to add the number of controls found to each case in or-
#der to remove cases without controls or where very few controls have been
#found.  This is easily obtained using data.table - with the example above:
#out5[,numControls:=.N,by=case.id] # adds a column with the number of controls
                                 # for each case-ID
}
\seealso{
matchReport Matchit
}
\author{
Christian Torp-Pedersen & Thomas Alexander Gerds
}
