% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MCRiskSetMatch.R
\name{RiskSetMatchMC}
\alias{RiskSetMatchMC}
\title{RiskSetMatch - Risk set matching}
\usage{
RiskSetMatchMC(ptid, event, terms, dat, Ncontrols, reuseCases = FALSE,
  reuseControls = FALSE, caseIndex = NULL, controlIndex = NULL,
  NoIndex = FALSE, cores = 10)
}
\arguments{
\item{ptid}{- Personal ID variable defining participant}

\item{event}{- Defines cases/controls MUST be 0/1}

\item{terms}{- c(.....) the variables that should be matched by}

\item{dat}{- The single dataset with all information - must be data.table}

\item{Ncontrols}{- Number of controls soucht for each case}

\item{reuseCases}{- T/F If T a case can be a control prior to being a case}

\item{reuseControls}{- T/F If T a control can be reused for several cases}

\item{caseIndex}{- Date variable defining the date where a case becomes a case}

\item{controlIndex}{- date variable defining the control data that needs to be larger chan caseIndex}

\item{NoIndex}{- if TRUE caseIndex/controlIndex are ignosed}

\item{cores}{- Number of cores to use. Defaults to max of available and 10

\bold{Details}
The function does exact matching and keep 2 dates apart.

This is a multicore version of a very related function RiskSetMatch that uses a single core. This version is useful
for large tasks that may take many hours on a single core.  For smaller sets the single core version is likely to 
be faster since the overhead of distributing to cores is large.

Because the matching is exact all matching variables must be integer or character. Make sure that
sufficient rounding is done on continuous variables to ensure a decent number of controls for each case.
For example it may be difficult to find controls for very high age cases and age should often be rounded 
by 2,3 og 5 years - and further aggregating extreme ages.

For many purposes controls should be reused and cases allowed to be controls prior to being cases. The function
provides some statistics where You should make sure that reuse of cases/controls is not extreme - which may 
cause bias.

With small samples the function is fast.  With extreme number of cases the calculation time can be many hours.
With long computations times please use the sister of this program RiskSetMatchMC where multiple cores can be 
applied

The function can be used for standard matching without the caseIndex/controlIndex, but other packages
such as MatchIt should preferably be used in these cases.}
}
\value{
data.table with cases and controls. A new variable "caseid" links controls to cases. Further the value of caseIndex
is added to controls.  Other variables in the original dataset are preserved unchanged. 
The final dataset includes all original cases but only the controls that were selected.
}
\description{
RiskSetMatch - Risk set matching
}
\examples{
require(data.table)
event <- c(rep(0,20),rep(1,5)) 
ptid <- 1:25
sex <- c(rep("fem",10),rep("mal",10),"fem","fem",rep("mal",3))
age <- c(rep(c(70,80),10),70,80,70,70,80)
caseIndex <- c(seq(10,28,2),seq(5,25,5))
controlIndex <- caseIndex
dat <- data.table(ptid,event,sex,age,caseIndex,controlIndex)
# Very simple match without reuse - no dates to control for
out <- RiskSetMatchMC("ptid","event",c("age","sex"),dat,2,NoIndex=TRUE,cores=2)
# Risk set matching without reusing cases/controls - 3 cases get no controls
out2 <- RiskSetMatchMC("ptid","event",c("age","sex"),dat,2,caseIndex="caseIndex",controlIndex="controlIndex",cores=2)
# Risk set matching with reuse of cases (control prior to case) and reuse of controls
out3 <- RiskSetMatchMC("ptid","event",c("age","sex"),dat,2,caseIndex="caseIndex",controlIndex="controlIndex"
         ,reuseCases=TRUE,reuseControls=TRUE,cores=2)
}
