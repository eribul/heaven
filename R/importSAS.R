##' Selective import of sas7bdat files into R data.table format
##'
##' This function first writes SAS code, then runs the SAS code, and finally data.table::freads the results into R.
##' The user selects which columns and rows to import. See examples.
##' @title importSAS
##' @aliases importSAS contentSAS
##' @usage importSAS(filename,wd=NULL,keep=NULL,drop = NULL,
##'                  where = NULL,obs = NULL,filter = NULL,
##'                  set.hook=NULL,step.hook=NULL,pre.hook=NULL,
##'                  post.hook=NULL,savefile = NULL,overwrite = TRUE,
##'                  show.sas.code=TRUE,save.tmp = FALSE,content=FALSE,
##'                  na.strings=".",...)
##'        contentSAS(filename,wd=NULL)
##' @param filename The filename (with full path) of the SAS dataset to import.
##' @param wd The directory used to store temporarily created files (SAS script, log file, csv file). You need to have permission to write to this directory. The default value is the working directory (which you may not have access to write to!).
##' @param keep Specifies the variables (columns) to include from the dataset. Default is to include all variables. Use SAS syntax (see examples).
##' @param drop Specifies the variables (columns) to leave out from the dataset. Default is to leave out no variables. Use SAS syntax (see examples).
##' @param where Specifies which conditions the observations (rows) from the dataset should fulfil. Default is no conditions. Use SAS syntax (see examples).
##' @param obs Number of observations to read from the dataset.
##' @param filter Alternative or in addition to the where statement it is possible to filter the rows of \code{filename} based on a data.table. E.g., filter can be a data.table with one column consisting of *unique* PNRs to specify that only matching rows should be imported from filename.
##' @param set.hook Quoted SAS statments (within use single quotes) to be placed in addition to set options (where, keep, drop, obs) when setting the data set \code{filename}. See examples.
##' @param step.hook Quoted SAS statments (within use single quotes) to be placed after setting the data set \code{filename}. See examples.
##' @param pre.hook Quoted SAS code (within use single quotes) to be set in the beginning of the SAS program. For example, it maybe useful to specify options such as \code{'options obs=100;'} in combination with a where statement.
##' @param post.hook Quoted SAS code (within use single quotes) to be set at the end of the SAS program. For example, it maybe useful to specify 'proc print data=df;' in case of trouble.
##' @param savefile If specified, the generated csv file will be saved with the given name. The name should end with ".csv". The file will be saved in the working directory or in the directory given under \code{wd} if this is specified.
##' @param overwrite Logical. Determines whether or not to overwrite files already existing with the same name as files generated by this function. This is the temporary SAS file, log file and csv file, and possibly a permanent file with the name given under "savefile". If the value is FALSE and some files already exist, the function will abort and print the name of the problematic files. The default value is TRUE.
##' @param show.sas.code Logical. If \code{TRUE} show sas code in R console before running it.
##' @param save.tmp Logical. Option to save all temporary files. Even though this is set to FALSE, the csv file will be saved if there is given a filename in "savefile". Default value is FALSE.
##' @param content Logical. If true, the function will only read and return the content of the import file. Together with save.tmp=TRUE, this can be used to generate the SAS file without running it.
##' @param na.strings A vector of strings to interpret as NA. Argument parsed to \code{fread} so see this help page for more information. 
##' @param ... Arguments parsed to \code{fread} for reading the created .csv file. 
##' @return The output is a data.table with the columns requested in keep (or all columns) and the rows requested in where (or all rows) up to obs many rows.
##' @author Anders Munch \email{a.munch@sund.ku.dk} and Thomas A Gerds \email{tag@biostat.ku.dk}
##' @references This function is based on pioneering work by Jesper Lindhardsen.
##' @examples
##' # We first set a working directory in which we have read and write permission
##' # These functions will produce temporary files which, if save.tmp is not set to TRUE, will
##' # be removed afterwards.
##' \dontrun{
##' setwd("v:/Data/Workdata/704791/AndersMunch/readSAS/R")
##'
##' # Before importing a SAS data file it is useful to look into the
##' # format of the variables:
##' contentSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl")
##' contentSAS(filename="x:/Data/Rawdata_Hurtig/704791/pop.sas7bdat")
##'
##' # Also, it is often a good idea to initially only read a limited amount of data
##' df101 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",obs=101,save.tmp=TRUE)
##' # and to examine the result
##' str(df101)
##' df101
##' # we can also use the pre.hook to limit the number of observations via sas options:
##' importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'           pre.hook="options obs=17;",where="diag='DN899'",keep=c("PNR","diag"),show.sas.code=1L)
##'
##' # NOTE: In combination with a where statement SAS will find the first 101 observations that
##' #       satisfy the where statement. When the where statement finds nothing then SAS
##' #       will run through the whole file without finding anything
##'
##' # To import the whole file just remove the limitations:
##' # df <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",show.sas.code=TRUE)
##' # But: this is not useful when files are huge and you should to look
##' # at the examples below which show how to read selected columns and rows only
##'
##' # In huge data it is efficient to select only the required columns
##' # and to read only the rows of the data set that meet a criterion.
##' # The following example shows how to select columns with the keep option
##' # and how to specify the "where statement" of the SAS data step:
##' df0 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=101,
##'                  keep=c("diag","diagtype"),
##'                  where="diagtype = 'A' and diag = '45490'")
##'
##' # Examine the imported data.table
##' str(df0)
##' df0
##' # using where contains is powerful
##' importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=10,
##'                  save.tmp=TRUE,
##'                  where="diag contains 'DI2'",
##'                  keep=c("PNR","diag","inddto","uddto"))
##'
##'
##' # Another typical task is to import only the rows which correspond to
##' # a set of pnr numbers or a set of diagnoses or both.
##' # To achieve this the function importSAS is merging files during the import.
##' # The feature is called 'filter' and illustrated in the following examples:
##' # Example 1: import only rows of diag_indl which correspond to one of the
##' #            first 23 pnr's in pop
##' pop <- importSAS(filename="x:/Data/Rawdata_Hurtig/704791/pop.sas7bdat",
##'                  obs=23,keep="PNR")
##' df1 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=8501,filter=pop)
##' str(df1)
##' df1
##'
##' # Example 2: import only rows of diag_indl which correspond the
##' #            first pnr's in pop for which also diag is equal to DK409
##' pop2 <- importSAS(filename="x:/Data/Rawdata_Hurtig/704791/pop.sas7bdat",
##'                  obs=4223,keep="PNR")
##' pop2 <- pop2[,diag:="DZ508"]
##' df2 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=8501,keep=c("pnr","diag","inddto","uddto","pattype"),
##'                  where="pattype ne 3",filter=pop2)
##' str(df2)
##' df2
##'
##' # The hooks set.hook and step.hook can be used as follows:
##' df3 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=101,
##'                  keep=c("PNR","diag","diagtype"),
##'                  set.hook="firstobs=5",
##'                  step.hook="by PNR; firstPNR=first.PNR;",
##'                  where="diag contains 'I'")
##' str(df3)
##' df3
##'
##' # Because the "overwrite" argument is FALSE, running the above code again will abort the import
##' # to not overwrite the temporary files.
##' # Setting "overwrite=TRUE" will allow the function to overwrite the files.
##'
##' }
##' @export
importSAS <- function(filename,
                      wd=NULL,
                      keep=NULL,
                      drop = NULL,
                      where = NULL,
                      obs = NULL,
                      filter = NULL,
                      set.hook=NULL,
                      step.hook=NULL,
                      pre.hook=NULL,
                      post.hook=NULL,
                      savefile = NULL,
                      overwrite = TRUE,
                      show.sas.code=TRUE,
                      save.tmp = FALSE,
                      content = FALSE,
                      na.strings=".",
                      ...){
    .SD=NULL
    # {{{ Clean up.
    on.exit({
        if(!save.tmp){
            for (file in files[!files==outfile]) {
                if(file.exists(file)) file.remove(file)
            }
            if(length(savefile)==0) if(file.exists(outfile)) file.remove(outfile)
        }
        setwd(olddir)
    })
    # }}}
    # {{{ Setup tmp file structure
    existing.files <- NULL
    olddir <- getwd() # remember old wd
    if(length(wd)==0) wd <- getwd()
    setwd(wd)
    # Names of temporary files
    tmp.SASfile <- paste(wd,"/", "sasimport_internal_tmpfile.sas", sep="")
    tmp.log <- paste(wd,"/", "sasimport_internal_tmpfile.log", sep ="")
    tmp.filterfile <- paste(wd,"/", "sasimport_internal_tmpfilterfile.csv", sep="")
    tmp.SASproccont <- paste(wd,"/", "sasimport_internal_tmpproccont.sas", sep="")
    tmp.proccontout <- paste(wd,"/", "sasimport_internal_tmpproccontout.csv", sep="")
    tmp.proccontlog <- paste(wd,"/", "sasimport_internal_tmpproccont.log", sep ="")
    try.val <- try(file.create(tmp.SASfile)) # Try first to see if dir is ok.
    if(!try.val) stop("Aborted. \nYou probably do not have permission to write to the directory: \n ",
                      wd,
                      "\nTry to specify another directory with the argument \"wd\" or change the working directory.",
                      sep = "")
    if(length(savefile)>0){
        outfile <- paste(wd,"/", savefile, sep="")
    }else{
        outfile <- paste(wd,"/", "sasimport_internal_tmpout.csv", sep ="")
    }
    # Check if files to be generated already exist
    files <- c(tmp.SASfile,tmp.log,tmp.filterfile,outfile,tmp.SASproccont,tmp.proccontout,tmp.proccontlog)
    for (file in files){
        if(file.exists(file)) existing.files <- c(existing.files, basename(file))
    }
    if(length(existing.files)>0 & overwrite == FALSE){
        stop(paste("Aborted to not overwrite the file(s):",
                   paste(" ", existing.files, collapse = "\n"),
                   "in the directory:",
                   paste(" ", wd),
                   "Set the argument \"overwrite\" equal to \"TRUE\" to allow overwriting.",
                   sep = "\n"))
    }
    for (file in files){
        if(file.exists(file)) file.remove(file)
    }
    # }}}
    # {{{ Conditions
    cond <- ""
    ## if(length(keep)+length(drop)+length(where)+length(obs)){
    if(length(keep) >0) {cond <- paste(cond, "keep=", paste(keep, collapse=" "), " ", sep="")}
    if(length(drop) >0) {cond <- paste(cond, "drop=", paste(drop, collapse=" "), " ", sep="")}
    if(length(where)>0) {cond <- paste(cond, "where=(", where, ") ", sep="")}
    if(length(obs)  >0) {cond <- paste(cond, "obs=", format(obs, scientific=FALSE), " ", sep="")}
    if (length(cond)>0){
        if (length(set.hook)>0 & is.character(set.hook))
            cond <- paste("(",cond, set.hook, ")", sep=" ")
        else
            cond <- paste("(",cond,")", sep=" ")
    }
    # }}}
    # {{{ Proc content
    file.create(tmp.SASproccont)
    cat("ods listing close;\nODS OUTPUT variables=dcontent; \n proc contents data='",
        filename, "';\nrun;\nproc sort data=dcontent;\nby num;\nrun; \ndata _NULL_; \nset dcontent; \n file '",
        tmp.proccontout,
        "' dsd; \nif _n_ eq 1 then link names; \nput (_all_)(~); return; \nnames:\nlength _name_ $32; \ndo while(1); \ncall vnext(_name_); \nif upcase(_name_) eq '_NAME_' then leave; \nput _name_ ~ @; \nend; \nput; \nreturn; \nrun;",
        sep = "",
        file = tmp.SASproccont,
        append = TRUE)
    fprog <- paste0("\"\"C:/Program Files/SASHome/SASFoundation/9.4/sas.exe\" ",
                    "-batch -nosplash -noenhancededitor -sysin \"",
                    tmp.SASproccont,
                    "\"\"")
    shell(fprog)
    # Read the created file
    dt.content <- data.table::fread(file = tmp.proccontout, header = TRUE)[,-1]
    # Should the filter also be compared with BOTH the keep/drop statements?
    var.names <- tolower(dt.content$Variable)
    var.format <- dt.content$Informat
    var.type <- dt.content$Type
    is.date <- grepl("date",var.format,ignore.case=TRUE) | grepl("dato",var.format,ignore.case=TRUE)
    is.num <- grepl("num",var.type,ignore.case=TRUE)
    is.num <- is.num & !is.date
    filter.names <- tolower(names(filter))
    keep.check <- drop.check <- filter.check <- TRUE
    if(length(keep)>0)   {keep.check <- tolower(keep) %in% var.names}
    if(length(drop)>0)   {drop.check <- tolower(drop) %in% var.names}
    if(length(filter)>0) {filter.check <- filter.names %in% var.names}
    if (length(keep)>0) is.date[!(var.names %in% keep)] <- FALSE
    if (length(drop)>0) is.date[(var.names %in% drop)] <- FALSE
    format.statement <- if (sum(is.date)==0) "" else paste("format ",paste(var.names[is.date],collapse=" ")," yymmdd10.;")
    # }}}
    # {{{ Write SAS program, import filterfile if present
    if (length(pre.hook)>0 & is.character(pre.hook)){
        cat(pre.hook,
            file = tmp.SASfile,
            append = TRUE)
    }
    if(length(filter)>0){
        data.table::fwrite(filter, quote = TRUE, file = tmp.filterfile)
        ### Import the csv file
        cat("proc import datafile='",
            tmp.filterfile,
            "' \n",
            "out = csv_import \ndbms =csv; \nrun; \n",
            sep = "",
            file = tmp.SASfile,
            append = TRUE)
    }
    ### Import filename data set
    cat("data df; \nset '", filename, "'", cond, ";\n",
        format.statement,
        sep = "",
        file =tmp.SASfile,
        append =TRUE)
    if (length(step.hook)>0 & is.character(step.hook)){
        cat(step.hook,
            sep = "",
            file =tmp.SASfile,
            append =TRUE)
    }
    cat("\nrun;\n",
        sep = "",
        file =tmp.SASfile,
        append =TRUE)
    if(length(filter)>0){
        ### Sort
        cat("proc sort data=csv_import; \nby ",
            paste(filter.names, collapse=" "),
            "; \nrun; \nproc sort data=df; \nby ",
            paste(filter.names, collapse=" "),
            "; \nrun; ",
            sep = "",
            file = tmp.SASfile,
            append=TRUE)
        ### Merge the files
        cat("data df; \nmerge csv_import(IN=a) df(IN=b); \nby ",
            paste(filter.names, collapse=" "),
            ";\nif a AND b;\nrun;\n",
            sep = "",
            file=tmp.SASfile,
            append=TRUE)
    }
    if (length(post.hook)>0 & is.character(post.hook)){
        cat(post.hook,
            file = tmp.SASfile,
            append = TRUE)
    }
    tmp.lines <- paste("data _NULL_; \nset df; \n file '",
                       outfile,
                       "' dsd; \nif _n_ eq 1 then link names; \nput (_all_)(~); return; \nnames:\nlength _name_ $32; \ndo while(1); \ncall vnext(_name_); \nif upcase(_name_) eq '_NAME_' then leave; \nput _name_ ~ @; \nend; \nput; \nreturn; \nrun;")
    cat(tmp.lines,
        file = tmp.SASfile,
        append = TRUE)
    if (show.sas.code==TRUE){
        cat("\nRunning the following sas code in the background. You can cancel SAS at any time.\n" )
        file.show(tmp.SASfile)
    }else{
        cat("\nRunning sas code in the background. You can cancel SAS at any time.\n" )
    }
    # }}}
    # {{{ Check for content or run the SAS file
    # construct error message
    if(!(prod(keep.check)*prod(drop.check)*prod(filter.check))){ # Check if ok.
        error.mes <- "Some of the variables specified in the keep or drop statement or in the filter file is not found in the import file.\n"
        if(length(keep)>0) error.mes <- paste(error.mes, "The KEEP argument(s): \n  ", paste(tolower(keep[!keep.check]), collapse="\n"),"\nare not found in the import file.\n", sep="")
        if(length(drop)>0) error.mes <- paste(error.mes, "The DROP argument(s): \n  ", paste(tolower(drop[!drop.check]), collapse="\n"),"\nare not found in the import file.\n", sep="")
        if(length(filter)>0) error.mes <- paste(error.mes, "The FILTER argument(s): \n  ", paste(filter.names[!filter.check], collapse="\n"),"\nare not found in the import file.\n", sep="")
        error.mes <- paste(error.mes, "\nThe content of the import file is:\n", sep="")
    }
    if(content==TRUE){
        df <- dt.content
        if(!(prod(keep.check)*prod(drop.check)*prod(filter.check))) {
            cat(paste("Warning:\n", error.mes, sep=""))
            print(df)
            cat("\nThis will give an error when content=FALSE.\n")
        }
    }else{
        if(!(prod(keep.check)*prod(drop.check)*prod(filter.check))) {
            cat(paste("Error:\n", error.mes, sep=""))
            print(dt.content)
            stop("Aborted.")
        }else{ # Exucute the sas file
            fprog <- paste0("\"\"C:/Program Files/SASHome/SASFoundation/9.4/sas.exe\" ",
                            "-batch -nosplash -noenhancededitor -sysin \"",
                            tmp.SASfile,
                            "\"\"")
            shell(fprog) # Collect this if it fails?
            ### Read the data
            if (!file.exists(outfile)){stop(paste("SAS did not produce output file. Maybe you have misspecified a SAS statement?\nRun with save.tmp=TRUE and then check the log file:",tmp.log))}
            info <- file.info(outfile)
            if(info$size==1){  # Check if outfile is empty
                warning("The constructed dataset is empty.")
                df <- NULL
            }else{
                tryread <- try(df <- data.table::fread(file = outfile, header = TRUE, na.strings=na.strings, ...))
                if ("try-error" %in% class(tryread)){
                    warning("Could not read the constructed dataset into R. \nSomething probably went wrong during SAS program execution. ")
                    df <- NULL
                }
            }
            if (!is.null(df) & sum(is.date)>0){
                date.vars <- var.names[is.date]
                #df[,(date.vars):=lapply(.SD,fasttime::fastPOSIXct),.SDcols=date.vars]
                df[,(date.vars):=lapply(.SD,lubridate::ymd),.SDcols=date.vars]
            }
        }
    }
    # }}}
    return(try(df[],silent=TRUE))
}
##' @export
contentSAS <- function(filename,wd=NULL){
    importSAS(filename=filename,wd=wd,content = TRUE)
}
