##' Selective import of sas7bdat files into R data.table format
##'
##' This function first writes SAS code, then runs the SAS code, and finally data.table::freads the results into R.
##' The user selects which columns and rows to import. See examples.
##' @title importSAS
##' @aliases importSAS contentSAS
##' @usage importSAS(filename,wd=NULL,keep=NULL,drop = NULL,
##'                  where = NULL,obs = NULL,filter = NULL,
##'                  filter.by = NULL, filter.cond = c(1,1),
##'                  set.hook=NULL,step.hook=NULL,pre.hook=NULL,
##'                  post.hook=NULL,savefile = NULL,overwrite = TRUE,
##'                  show.sas.code=TRUE,save.tmp = FALSE,content=FALSE,
##'                  na.strings=".",date.vars, character.vars="pnr",
##'                  numeric.vars = NULL,sas.program,sas.switches,
##'                  sas.runner, skip.date.conversion=FALSE,
##'                  sas.data.extension="sas7bdat", verbose=TRUE,...)
##'        contentSAS(filename,wd=NULL)
##' @param filename The filename (with full path) of the SAS dataset to import.
##' So, \code{"x:/data/rawdata/701111/lmdb.sas7bdat"} and also
##' \code{"v:/data/workdata/701111/MeMe/project1/data/mydata.sas7bdat"} work but \code{"./data/mydata.sas7bdat"}
##' does not even not if the working directory is set to \code{"v:/data/workdata/701111/MeMe/project1/"}.
##' @param wd The directory used to store temporarily created files (SAS script, log file, csv file). You need to
##'           have permission to write to this directory. The default value is the current working directory, see \code{getwd()},
##'           (which you may not have access to write to!). On Gentofte's Danmark Statistics servers it may help to set
##'           the working directory to the fast X drive. 
##' @param keep A vector of variable names, i.e., the variables (columns) to read and keep from the dataset. Default is to read and keep all variables. 
##' @param drop Specifies the variables (columns) to leave out from the dataset. Default is to leave out no variables.
##' @param where Specifies which conditions the observations (rows) from the dataset should fulfil. Default is no conditions. Use SAS syntax (see examples).
##' @param obs Number of observations to read from the dataset. Setting this to \code{Inf} has the same effect as not setting it, i.e, read all observations.  
##' @param filter Alternative or in addition to the where statement it is
##'               possible to filter the rows of \code{filename} based on a data.table.
##'               E.g., filter can be a data.table with one column consisting of *unique*
##'               PNRs to specify that only matching rows should be imported from filename.
##' @param filter.by Vector of arguments to filter by. Default is all variables present in the filter file. 
##' @param filter.cond Vector of two arguments equal to one of the values: -1,0,1.
##'                    The first argument conditions on values from the filter file,
##'                    the second on the SAS dataset. 1 means that an observation is only
##'                    included if it is present in the corresponding dataset, -1 means it is
##'                    excluded in this case, and 0 has no effect. Default is c(1,1).
##' @param set.hook Quoted SAS statments (within use single quotes) to be placed in addition to set options (where, keep, drop, obs) when setting the data set \code{filename}. See examples.
##' @param step.hook Quoted SAS statments (within use single quotes) to be placed after setting the data set \code{filename}. See examples.
##' @param pre.hook Quoted SAS code (within use single quotes) to be set in the beginning of the SAS program. For example, it maybe useful to specify options such as \code{'options obs=100;'} in combination with a where statement.
##' @param post.hook Quoted SAS code (within use single quotes) to be set at the end of the SAS program. For example, it maybe useful to specify 'proc print data=df;' in case of trouble.
##' @param savefile If specified, the generated csv file will be saved with the given name. The name should end with ".csv". The file will be saved in the working directory or in the directory given under \code{wd} if this is specified.
##' @param overwrite Logical. Determines whether or not to overwrite files already existing with the same name as files generated by this function. This is the temporary SAS file, log file and csv file, and possibly a permanent file with the name given under "savefile". If the value is FALSE and some files already exist, the function will abort and print the name of the problematic files. The default value is TRUE.
##' @param show.sas.code Logical. If \code{TRUE} show sas code in R console before running it.
##' @param save.tmp Logical. Option to save all temporary files. Even though this is set to FALSE, the csv file will be saved if there is given a filename in "savefile". Default value is FALSE.
##' @param content Logical. If true, the function will only read and return the content of the import file. Together with save.tmp=TRUE, this can be used to generate the SAS file without running it.
##' @param na.strings A vector of strings to interpret as NA. Argument parsed to \code{fread} so see this help page for more information. 
##' @param date.vars Vector of variables to read as date variables.
##' @param character.vars names of variables that should be converted to character. case does not matter. default is "pnr"
##' @param numeric.vars character.vars names of variables that should be converted to numeric. case does not matter. 
##' @param sas.program sas program. On linux where \code{.Platform$OS.type=="unix"} this defaults to \code{"sas"} on any other system to "C:/Program Files/SASHome/SASFoundation/9.4/sas.exe"
##' @param sas.switches On linux this defaults to {""} on any other system to \code{"-batch -nosplash -noenhancededitor -sysin"}
##' @param sas.runner How sas is invoked. On linux this defaults to \code{"system"} on any other system to \code{"shell"}.
##' @param skip.date.conversion if TRUE do not try to convert any dates.
##' @param sas.data.extension String to be checked against the file extenstion of filename. Default is \code{"sas7bdat"}.
##' @param verbose Logical. Bla bla on the screen?
##' @param ... Arguments passed to \code{fread} for reading the created .csv file. 
##' @return The output is a data.table with the columns requested in keep (or all columns) and the rows requested in where (or all rows) up to obs many rows.
##' @author Anders Munch \email{a.munch@sund.ku.dk} and Thomas A Gerds \email{tag@biostat.ku.dk}
##' @references This function is based on pioneering work by Jesper Lindhardsen.
##' @details As \code{R} is case-sensitive while \code{SAS} is not, to avoid confusion all variable names are converted to lower case. 
##' @examples
##' # We first set a working directory in which we have read and write permission
##' # These functions will produce temporary files which, if save.tmp is not set to TRUE, will
##' # be removed afterwards.
##'
##' \dontrun{
##' setwd("v:/Data/Workdata/704791/AndersMunch/readSAS/R")
##'
##' # Before importing a SAS data file it is useful to look into the
##' # format of the variables:
##' contentSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl")
##' contentSAS(filename="x:/Data/Rawdata_Hurtig/704791/pop.sas7bdat")
##'
##' # Also, it is often a good idea to initially only read a limited amount of data
##' df101 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",obs=101,save.tmp=TRUE)
##' # and to examine the result
##' str(df101)
##' df101
##'
##' # Format, dates, numeric, character
##' df101 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",obs=101,
##'                    save.tmp=TRUE,date.vars="inddto",
##'                    numeric.vars="pnr",character.vars="packsize")
##' 
##' # we can also use the pre.hook to limit the number of observations via sas options:
##' importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'           pre.hook="options obs=17;",where="diag='DN899'",keep=c("PNR","diag"),show.sas.code=1L)
##'
##' # NOTE: In combination with a where statement SAS will find the first 101 observations that
##' #       satisfy the where statement. When the where statement finds nothing then SAS
##' #       will run through the whole file without finding anything
##'
##' # To import the whole file just remove the limitations:
##' # df <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",show.sas.code=TRUE)
##' # But: this is not useful when files are huge and you should to look
##' # at the examples below which show how to read selected columns and rows only
##'
##' # In huge data it is efficient to select only the required columns
##' # and to read only the rows of the data set that meet a criterion.
##' # The following example shows how to select columns with the keep option
##' # and how to specify the "where statement" of the SAS data step:
##' df0 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=101,
##'                  keep=c("diag","diagtype"),
##'                  where="diagtype = 'A' and diag = '45490'")
##'
##' # Examine the imported data.table
##' str(df0)
##' df0
##' # using where contains is powerful
##' importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=10,
##'                  save.tmp=TRUE,
##'                  where="diag contains 'DI2'",
##'                  keep=c("PNR","diag","inddto","uddto"))
##'
##'
##' # Another typical task is to import only the rows which correspond to
##' # a set of pnr numbers or a set of diagnoses or both.
##' # To achieve this the function importSAS is merging files during the import.
##' # The feature is called 'filter' and illustrated in the following examples:
##' # Example 1: import only rows of diag_indl which correspond to one of the
##' #            first 23 pnr's in pop
##' pop <- importSAS(filename="x:/Data/Rawdata_Hurtig/704791/pop.sas7bdat",
##'                  obs=23,keep="PNR")
##' df1 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=8501,filter=pop)
##' str(df1)
##' df1
##'
##' # Example 2: import only rows of diag_indl which correspond the
##' #            first pnr's in pop for which also diag is equal to DK409
##' pop2 <- importSAS(filename="x:/Data/Rawdata_Hurtig/704791/pop.sas7bdat",
##'                  obs=4223,keep="PNR")
##' pop2 <- pop2[,diag:="DZ508"]
##' df2 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=8501,keep=c("pnr","diag","inddto","uddto","pattype"),
##'                  where="pattype ne 3",filter=pop2)
##' str(df2)
##' df2
##'
##' # The hooks set.hook and step.hook can be used as follows:
##' df3 <- importSAS(filename="X:/Data/Rawdata_Hurtig/704791/diag_indl",
##'                  obs=101,
##'                  keep=c("PNR","diag","diagtype"),
##'                  set.hook="firstobs=5",
##'                  step.hook="by PNR; firstPNR=first.PNR;",
##'                  where="diag contains 'I'")
##' str(df3)
##' df3
##'
##' # if you are more fluent in SAS than in R it may help to
##' # know how to communicate e.g., a keep statement, instead of
##' # using the keep argument:
##'
##' df4 <-importSAS(filename="X:/Data/Rawdata_Hurtig/999999/Dream201801",
##'                 set.hook="keep=pnr branch:",
##'                 obs=1000)
##'
##' # Because the "overwrite" argument is FALSE, running the above code again will abort the import
##' # to not overwrite the temporary files.
##' # Setting "overwrite=TRUE" will allow the function to overwrite the files.
##'
##' }
##' @export
importSAS <- function(filename, wd = NULL, keep = NULL, drop = NULL, where = NULL,
                       obs = NULL, filter = NULL, filter.by = NULL, filter.cond = c(1, 1),
                       set.hook = NULL, step.hook = NULL, pre.hook = NULL,
                       post.hook = NULL, savefile = NULL, overwrite = TRUE, show.sas.code = TRUE,
                       save.tmp = FALSE, content = FALSE, na.strings = ".", date.vars = NULL,
                       character.vars = "pnr", numeric.vars = NULL, sas.program,
                       sas.switches, sas.runner, skip.date.conversion = FALSE, 
                       sas.data.extension="sas7bdat",verbose = TRUE,
                       ...)
{
    if (!file.exists(filename)){
        stop(paste0("A file with name ",filename," does not exist."))
    }else{
        if (tolower(tools::file_ext(filename))!=sas.data.extension)
            stop("The filename exists, but file extension does not match sas.data.extension: ",sas.data.extension)
    }
    ## DD <- dirname(filename)
    ## FF <- basename(filename)
    ## fullname <- list.files(path=DD,pattern=paste0("^",filename,"$"),full.names=TRUE)
    .SD = NULL
    keep <- tolower(keep)
    drop <- tolower(drop)
    date.vars <- tolower(date.vars)
    olddir <- getwd()
    if (length(wd) == 0){
        wd <- getwd()
    }else{
        setwd(wd)
    }
                                        # cleaning up old temporary directories
    olddirectories <- list.files(wd,pattern="heaven_tempSASfiles[a-z0-9]+")
    for (old in olddirectories){
        message("Cleaning up temporary directories from previous calls.")
        unlink(old,recursive=TRUE,force=TRUE)
    }
    tmpname <- basename(tempfile(pattern="heaven_tempSASfiles"))
    tmpdir = paste0(wd,"/",tmpname)
    if (verbose) message("Writing temporary SAS files (log, lst, input data, output data) to directory\n",tmpdir)
    if (file.exists(tmpdir)) {
        stop(paste("file.exists:",tmpdir))
    }else{
        try.val <- try(dir.create(tmpdir))
        if (class(try.val)[[1]]=="try-error")
            stop("Cannot create temporary directory.\nYou probably do not have permission to write to the directory: \n ",
                 tmpdir, "\nTry to specify another directory with the argument \"wd\" or change the working directory.",
                 sep = "")
    }
    if (length(savefile) > 0) {
        outfile <- paste(wd, "/", savefile, sep = "")
        if (file.exists(outfile)) {
            if (interactive()){
                maybestop <- utils::askYesNo(paste0("Overwrite existing file: ",outfile,"? "))
                if (is.na(maybestop)||maybestop==FALSE){
                    stop("File exists:",outfile)
                }
            }else{
                stop("File exists:",outfile)
            }
        }
        message("The output of SAS will be saved to file:\n",outfile)
    }
    else {
        outfile <- paste(tmpdir, "/", "sasimport_internal_tmpout.csv",
                         sep = "")
    }
    setwd(tmpdir)
    on.exit({
        setwd(olddir)
        if (!save.tmp) {
            unlink(tmpdir,recursive=TRUE,force=TRUE)
        }else{
            cat("\nTemporary directory:\n ",tmpdir,"\ncan now be inspected -- and should be removed manually afterwards!\n")
        }
    })
    if (.Platform$OS.type == "unix") {
        if (missing(sas.program)) {
            sas.program <- "sas"
        }
        if (missing(sas.switches)) {
            sas.switches <- ""
        }
        if (missing(sas.runner)) {
            sas.runner <- "system"
        }
    }
    else {
        if (missing(sas.program)) {
            sas.program <- "C:/Program Files/SASHome/SASFoundation/9.4/sas.exe"
        }
        if (missing(sas.switches)) {
            sas.switches <- "-batch -nosplash -noenhancededitor -sysin "
        }
        if (missing(sas.runner)) {
            sas.runner <- "shell"
        }
    }
    existing.files <- NULL
    tmp.SASfile <- paste(tmpdir, "/", "sasimport_internal_tmpfile.sas",
                         sep = "")
    tmp.log <- paste(tmpdir, "/", "sasimport_internal_tmpfile.log",
                     sep = "")
    tmp.filterfile <- paste(tmpdir, "/", "sasimport_internal_tmpfilterfile.csv",
                            sep = "")
    tmp.SASproccont <- paste(tmpdir, "/", "sasimport_internal_tmpproccont.sas",
                             sep = "")
    tmp.proccontout <- paste(tmpdir, "/", "sasimport_internal_tmpproccontout.csv",
                             sep = "")
    tmp.proccontlog <- paste(tmpdir, "/", "sasimport_internal_tmpproccont.log",
                             sep = "")
    try.val <- try(file.create(tmp.SASfile))

    files <- c(tmp.SASfile, tmp.log, tmp.filterfile, outfile,
               tmp.SASproccont, tmp.proccontout, tmp.proccontlog)
    for (file in files) {
        if (file.exists(file))
            existing.files <- c(existing.files, basename(file))
    }
    if (length(existing.files) > 0 & overwrite == FALSE) {
        stop(paste("Aborted to not overwrite the file(s):", paste(" ",
                                                                  existing.files, collapse = "\n"), "in the directory:",
                   paste(" ", tmpdir), "Set the argument \"overwrite\" equal to \"TRUE\" to allow overwriting.",
                   sep = "\n"))
    }
    for (file in files) {
        if (file.exists(file))
            file.remove(file)
    }
    cond <- ""

    ## ----------------------------- start proc contents -------------------------
    file.create(tmp.SASproccont)
    cat("ods listing close;\nODS OUTPUT variables=dcontent; \n proc contents data='",
        filename, "';\nrun;\nproc sort data=dcontent;\nby num;\nrun; \ndata _NULL_; \nset dcontent; \n file '",
        tmp.proccontout, "' dsd; \nif _n_ eq 1 then link names; \nput (_all_)(~); return; \nnames:\nlength _name_ $32; \ndo while(1); \ncall vnext(_name_); \nif upcase(_name_) eq '_NAME_' then leave; \nput _name_ ~ @; \nend; \nput; \nreturn; \nrun;\n",
        sep = "", file = tmp.SASproccont, append = TRUE)
    if (.Platform$OS.type == "unix")
        fprog <- paste0(sas.program, " ", sas.switches, " ",
                        tmp.SASproccont)
    else fprog <- paste0("\"\"", sas.program, "\" ", sas.switches,
                         "\"", tmp.SASproccont, "\"\"")
    runcontents <- try(do.call(sas.runner, list(fprog)), silent = FALSE)
    if (class(runcontents)[1] == "try-error") {
        warning(paste("Running sas on", fprog, "yielded the error shown above."))
    }
    if (file.exists(tmp.proccontout)) {
        dt.content <- data.table::fread(file = tmp.proccontout,
                                        header = TRUE)[, -1]
    }
    else {
        stop(paste("Running sas on", fprog, "did not produce the expected output file."))
    }
    var.names <- tolower(dt.content$Variable)
    var.format <- dt.content$Informat
    var.type <- dt.content$Type
    ## ----------------------------- end proc contents -------------------------

    if (length(keep) > 0) {
        ## make life easier for the user
        keep <- c(keep, date.vars, numeric.vars, character.vars)
        if ("pnr" %in% var.names) {
            if (!("pnr" %in% keep)) keep <- c("pnr",keep)
        }
        cond <- paste(cond, "keep=", paste(keep, collapse = " "),
                      " ", sep = "")
    }
    if (length(drop) > 0) {
        cond <- paste(cond, "drop=", paste(drop, collapse = " "),
                      " ", sep = "")
    }
    if (length(where) > 0) {
        cond <- paste(cond, "where=(", where, ") ", sep = "")
    }
    if (length(obs) > 0 && !is.infinite(obs)) {
        cond <- paste(cond, "obs=", format(obs, scientific = FALSE),
                      " ", sep = "")
    }
    if (length(cond) > 0) {
        if (length(set.hook) > 0 & is.character(set.hook))
            cond <- paste("(", cond, set.hook, ")", sep = " ")
        else cond <- paste("(", cond, ")", sep = " ")
    }
    is.date <- grepl("date", var.format, ignore.case = TRUE) |
        grepl("dato", var.format, ignore.case = TRUE)
    is.num <- grepl("num", var.type, ignore.case = TRUE)
    is.num <- is.num & !is.date
    if (length(filter)>0){
        ## convert filter variables to lower
        orig.filter.names <- copy(names(filter))
        setnames(filter,tolower(names(filter)))
        if (length(filter.by) == 0) {
            filter.names <- names(filter)
        }
        else {
            filter.names <- tolower(filter.by)
        }
    }
    keep.check <- drop.check <- filter.check <- TRUE
    if (length(keep) > 0) {
        keep.check <- tolower(keep) %in% var.names
    }
    if (length(drop) > 0) {
        drop.check <- tolower(drop) %in% var.names
    }
    if (length(filter) > 0) {
        filter.check <- filter.names %in% var.names
    }
    if (length(keep) > 0)
        is.date[!(var.names %in% keep)] <- FALSE
    if (length(drop) > 0)
        is.date[(var.names %in% drop)] <- FALSE
    if (!is.null(date.vars))
        for (name in date.vars) {
            if (!(name %in% var.names))
                warning(paste(name, "not found in dataset."))
            else is.date[which(name == var.names)] <- TRUE
        }
    date.vars <- var.names[is.date]
    format.statement <- if (!any(is.date))
                            ""
                        else paste("format ", paste(date.vars, collapse = " "), " yymmdd10.;")
    if (length(pre.hook) > 0 & is.character(pre.hook)) {
        cat(pre.hook, file = tmp.SASfile, append = TRUE)
    }
    if (length(filter) > 0) {
        data.table::fwrite(filter, quote = TRUE, file = tmp.filterfile)
        cat("proc import datafile='", tmp.filterfile, "' \n",
            "out = csv_import \ndbms =csv; \nrun; \n", sep = "",
            file = tmp.SASfile, append = TRUE)
    }
    cat("data df; \nset '",filename,"'",cond,";\n",format.statement,sep = "",file = tmp.SASfile,append = TRUE)
    if (length(step.hook) > 0 & is.character(step.hook)) {
        cat(step.hook, sep = "", file = tmp.SASfile, append = TRUE)
    }
    cat("\nrun;\n", sep = "", file = tmp.SASfile, append = TRUE)
    if (length(filter) > 0) {
        cat("proc sort data=csv_import; \nby ", paste(filter.names,
                                                      collapse = " "), "; \nrun; \nproc sort data=df; \nby ",
            paste(filter.names, collapse = " "), "; \nrun;\n ",
            sep = "", file = tmp.SASfile, append = TRUE)
        tmp.merge.statement <- matrix(paste(c("( NOT", "( "),
                                            rep(letters[1:2], each = 2), ")"), ncol = 2)
        tmp.merge.statement <- rbind(tmp.merge.statement[1, ],
                                     rep("", 2), tmp.merge.statement[2, ])
        if (any(filter.cond == 0)) {
            if (all(filter.cond == 0)) {
                merge.cond.statement <- ""
            }
            else {
                merge.cond.statement <- paste("if", tmp.merge.statement[(filter.cond[filter.cond !=
                                                                                     0] + 2), which(filter.cond != 0)], ";\n")
            }
        }
        else {
            merge.cond.statement <- paste("if", tmp.merge.statement[(filter.cond[1] +
                                                                     2), 1], "AND", tmp.merge.statement[(filter.cond[2] +
                                                                                                         2), 2], ";\n")
        }
        cat("data df; \nmerge csv_import(IN=a) df(IN=b); \nby ",
            paste(filter.names, collapse = " "), ";\n", merge.cond.statement,
            "run;\n", sep = "", file = tmp.SASfile, append = TRUE)
    }
    if (length(post.hook) > 0 & is.character(post.hook)) {
        cat(post.hook, file = tmp.SASfile, append = TRUE)
    }
    if (show.sas.code == TRUE) {
        cat("\nRunning the following sas code in the background.\nYou can cancel SAS at any time.\n")
        cat("\n-------------------------SAS-code-------------------------\n")
        cat(readChar(tmp.SASfile, file.info(tmp.SASfile)$size))
        cat("\n----------------------------------------------------------\n")
    }
    else {
        if (verbose)
            cat("\nRunning sas code in the background. You can cancel SAS at any time.\n")
    }
    tmp.lines <- paste("data _NULL_; \nset df; \n file '", outfile,
                       "' dsd; \nif _n_ eq 1 then link names; \nput (_all_)(~); return; \nnames:\nlength _name_ $32; \ndo while(1); \ncall vnext(_name_); \nif upcase(_name_) eq '_NAME_' then leave; \nput _name_ ~ @; \nend; \nput; \nreturn; \nrun;\n")
    cat(tmp.lines, file = tmp.SASfile, append = TRUE)
    if (!(prod(keep.check) * prod(drop.check) * prod(filter.check))) {
        error.mes <- "Some of the variables specified in the keep or drop statement or in the filter file is not found in the import file.\n"
        if (length(keep) > 0)
            error.mes <- paste(error.mes, "The KEEP argument(s): \n  ",
                               paste(tolower(keep[!keep.check]), collapse = "\n"),
                               "\nare not found in the import file.\n", sep = "")
        if (length(drop) > 0)
            error.mes <- paste(error.mes, "The DROP argument(s): \n  ",
                               paste(tolower(drop[!drop.check]), collapse = "\n"),
                               "\nare not found in the import file.\n", sep = "")
        if (length(filter) > 0)
            error.mes <- paste(error.mes, "The FILTER argument(s): \n  ",
                               paste(filter.names[!filter.check], collapse = "\n"),
                               "\nare not found in the import file.\n", sep = "")
        error.mes <- paste(error.mes, "\nThe content of the import file is:\n",
                           sep = "")
    }
    if (content == TRUE) {
        df <- dt.content
        if (!(prod(keep.check) * prod(drop.check) * prod(filter.check))) {
            cat(paste("Warning:\n", error.mes, sep = ""))
            print(df)
            cat("\nThis will give an error when content=FALSE.\n")
        }
    }
    else {
        if (!(prod(keep.check) * prod(drop.check) * prod(filter.check))) {
            cat(paste("Error:\n", error.mes, sep = ""))
            print(dt.content)
            stop("Aborted.")
        }
        else {
            if (.Platform$OS.type == "unix") {
                fprog <- paste0(sas.program, " ", sas.switches,
                                " ", tmp.SASfile)
            }
            else {
                fprog <- paste0("\"\"", sas.program, "\" ", sas.switches,
                                "\"", tmp.SASfile, "\"\"")
            }
            runSAS <- try(do.call(sas.runner, list(fprog)), silent = FALSE)
            if (class(runSAS)[1] == "try-error") {
                warning(paste("Running sas on", fprog, "yielded the error shown above."))
            }
            if (!file.exists(outfile)) {
                stop(paste0("SAS did not produce output file. Maybe you have misspecified a SAS statement?",
                            ifelse(save.tmp == FALSE, "\nRun with save.tmp=TRUE and then",
                                   "\nPlease"), " check the log file:\n", tmp.log))
            }
            info <- file.info(outfile)
            ia <- c(list(file = outfile, header = TRUE, na.strings = na.strings),
                    list(...))
            if (length(ia$colClasses) == 0)
                ia$colClasses <- list(character = NULL, numeric = NULL)
            for (v in character.vars) {
                if (length(vname <- grep(v, dt.content$Variable,
                                         value = TRUE, ignore.case = TRUE)) > 0)
                    if (length(filter) > 0){
                        if (tolower(vname) %in% filter.names) vname <- tolower(vname)
                    }
                ia$colClasses[["character"]] <- unique(c(vname,ia$colClasses[["character"]]))
            }
            for (v in numeric.vars) {
                if (length(vname <- grep(v, dt.content$Variable,
                                         value = TRUE, ignore.case = TRUE)) > 0) {
                    if (length(filter) > 0){
                        if (tolower(vname) %in% filter.names) vname <- tolower(vname)
                    }
                    ia$colClasses[["numeric"]] <- unique(c(vname,
                                                           ia$colClasses[["numeric"]]))
                }
            }
                                        # reset filternames
            if (length(filter) > 0){
                setnames(filter,orig.filter.names)
            }
            if (info$size == 1) {
                warning("The dataset produced by SAS appears to be empty.")
                df <- NULL
            }
            else {
                tryread <- try(df <- do.call(data.table::fread,ia))
                if ("try-error" %in% class(tryread)) {
                    warning("Could not read the constructed dataset into R. \nSomething probably went wrong during SAS program execution. ")
                    df <- NULL
                }
            }
            if (skip.date.conversion == FALSE) {
                names(df) <- tolower(names(df))
                if (!is.null(df) & sum(is.date) > 0) {
                    date.vars <- tolower(date.vars)
                    try(df[, `:=`((date.vars), lapply(.SD, lubridate::ymd)),
                           .SDcols = date.vars], silent = FALSE)
                }
            }
        }
    }
    return(try(df[], silent = TRUE))
}

##' @export
contentSAS <- function(filename,wd=NULL){
    importSAS(filename=filename,wd=wd,content = TRUE)
}
