<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Paul Blanche, Christian Torp-Pedersen &amp; Thomas Gerds" />

<meta name="date" content="2018-12-23" />

<title>user-heaven</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">user-heaven</h1>
<h4 class="author"><em>Paul Blanche, Christian Torp-Pedersen &amp; Thomas Gerds</em></h4>
<h4 class="date"><em>2018-12-23</em></h4>



<p>Heaven includes a series of function that are useful when working with massive sized epidemiological data. The functions are specifically constructed for the Statistics Denmark environment. This particular environment delivers huge datasets in SAS. Some functions are generally useful, others only helpful for datasets as delivered by Statistics Denmark.</p>
<div id="overview" class="section level1">
<h1>Overview</h1>
<div id="reading-data" class="section level2">
<h2>Reading data</h2>
<ul>
<li>readSAS Extract selected data from large SAS datasets. SAS does the main work in background</li>
<li>importDREAM Reads the DREAM dataset regarding state subsidizing and profession</li>
<li>searchEvent Search for an event in specified time period for each individual</li>
<li>getAdmLimits Sets start and end to hospitalisations with multiple records</li>
<li>extractCode Extraction of diseases by diagnoses</li>
</ul>
</div>
<div id="standardizing" class="section level2">
<h2>Standardizing</h2>
<ul>
<li>standardize.rate Standardizes rates to given age distribution</li>
<li>Standardize.proportion Standardizes proportions to age distribution</li>
<li>standardize.prodlim Compute standardized absolute risks based on a stratified Kaplan-Meier or Aalen-Johansen estimate</li>
</ul>
</div>
<div id="simulation" class="section level2">
<h2>Simulation</h2>
<ul>
<li>simpoisson Simulates data for Poisson distribution</li>
</ul>
</div>
<div id="matching" class="section level2">
<h2>Matching</h2>
<ul>
<li>riskSetMatch Risk set matching for incidense density samptling and exposure density sampling</li>
<li>matchReport Provides data on matching success from riskSetMatch</li>
</ul>
</div>
<div id="calculation" class="section level2">
<h2>Calculation</h2>
<ul>
<li>poissonRisk Predicting absolute risks from poisson regression</li>
<li>poissonregression Aggregates data and performs poisson regression using GLM</li>
<li>patientProfile Profile of common covariate combinations among patients</li>
</ul>
</div>
<div id="splitting" class="section level2">
<h2>Splitting</h2>
<ul>
<li>lexisTwo Splits by a set of covariates each causing at most one split</li>
<li>lexisFromTo Splits by a series of periods - from/to</li>
<li>lexisSeq Splits consecutively by a vector</li>
</ul>
</div>
</div>
<div id="importdream" class="section level1">
<h1>importDREAM</h1>
<p>The DREAM dataset is collected from a range of Danish authorities. Since 1991 it contains all residents that have received public support. Since this includes student funding from the state, prolonged sick leave, maternity leave and pension most of the Danish population is included. The dataset is contructed with one record per person and one variable per week since 1991. For each week there is a code if that person has received support. Further since 2008 there is a monthly recording of occupation of each individual in the dataset. For a detailed description of DREAM refer to www.dreammodel.dk</p>
<p>The importDREAM function reads an R data.table imported from SAS and returns a “long” list of support codes or profession codes along with person identification and dates of start and end.</p>
<div id="usage" class="section level2">
<h2>Usage</h2>
<p>importDREAM(dreamData,explData=NULL,type=“support”,pnr=“PNR”)</p>
<p>Author: Christian Torp-Pedersen</p>
<ul>
<li>dreamData Name of dataset holding DREAM data. Typically product of the importSAS function. In most cases it will be useful to add a set.hook to the importSAS function - set.hook=“keep PNR branch:” for type of work and set.hook=“keep=PNR y_:” for support</li>
<li>explData Name of data holding relation between codes and explanatory text. Typically read from “//srvfsenas1/formater/SAS formater i Danmarks Statistik/txt_filer” using “read.csv2”. The data is expected to hold two variables: the code and the explanation - in that order. The variable holding the code MUST be named “branche” or “support” as appropriate.</li>
<li>type - “support” extracts weekly public support and “branche” supplies montly type of work. Other names cause error.</li>
<li>pnr - name of person identifier in DREAM dataset, typically “PNR”</li>
</ul>
</div>
<div id="return" class="section level2">
<h2>Return</h2>
<p>the function returns a data.table with the following variables:</p>
<ul>
<li>pnr - person identificer from call</li>
<li>start - start of each period</li>
<li>end - end of each period</li>
<li>code - coding of period</li>
<li>explanation - text to eplain coding if a text dataset was specified</li>
</ul>
</div>
<div id="example" class="section level2">
<h2>Example</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co"># The following is a minute version of DREAM</span>
 <span class="kw">library</span>(data.table)
 <span class="kw">library</span>(heaven)
 microDREAM &lt;-<span class="kw">data.table</span>(<span class="dt">PNR=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>),<span class="dt">branche_2008_01=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;3&quot;</span>),
   <span class="dt">branche_2008_02=</span><span class="kw">c</span>(<span class="st">&quot;1&quot;</span>,<span class="st">&quot;3&quot;</span>), <span class="dt">branche_2008_03=</span><span class="kw">c</span>(<span class="st">&quot;1&quot;</span>,<span class="st">&quot;&quot;</span>),
   <span class="dt">y_9201=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;1&quot;</span>),<span class="dt">y_9202=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;2&quot;</span>),<span class="dt">y_9203=</span><span class="kw">c</span>(<span class="st">&quot;&quot;</span>,<span class="st">&quot;2&quot;</span>))
 microDREAM[]</code></pre></div>
<pre><code>##    PNR branche_2008_01 branche_2008_02 branche_2008_03 y_9201 y_9202
## 1:   1                               1               1              
## 2:   2               3               3                      1      2
##    y_9203
## 1:       
## 2:      2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co"># Explanation of codes for &quot;branche&quot; </span>
 branche &lt;-<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">branche=</span><span class="kw">c</span>(<span class="st">&quot;1&quot;</span>,<span class="st">&quot;2&quot;</span>,<span class="st">&quot;3&quot;</span>),
             <span class="dt">text=</span><span class="kw">c</span>(<span class="st">&quot;school&quot;</span>,<span class="st">&quot;gardening&quot;</span>,<span class="st">&quot;suage&quot;</span>))   
 support &lt;-<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">support=</span><span class="kw">c</span>(<span class="st">&quot;1&quot;</span>,<span class="st">&quot;2&quot;</span>),<span class="dt">text=</span><span class="kw">c</span>(<span class="st">&quot;education&quot;</span>,<span class="st">&quot;sick&quot;</span>)) 
 temp &lt;-<span class="st"> </span><span class="kw">importDREAM</span>(microDREAM,branche,<span class="dt">type=</span><span class="st">&quot;branche&quot;</span>,<span class="dt">pnr=</span><span class="st">&quot;PNR&quot;</span>)   
 temp[]</code></pre></div>
<pre><code>##    branche PNR      start        end   text
## 1:           1 2008-01-01 2008-02-01   &lt;NA&gt;
## 2:       1   1 2008-02-01 2008-01-01 school
## 3:       3   2 2008-01-01 2008-03-01  suage
## 4:           2 2008-03-01 2008-04-01   &lt;NA&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> temp2 &lt;-<span class="st"> </span><span class="kw">importDREAM</span>(microDREAM,support,<span class="dt">type=</span><span class="st">&quot;support&quot;</span>,<span class="dt">pnr=</span><span class="st">&quot;PNR&quot;</span>)
 temp2[]    </code></pre></div>
<pre><code>##    support PNR      start        end      text
## 1:           1 1991-12-30 1991-12-30      &lt;NA&gt;
## 2:       1   2 1991-12-30 1992-01-06 education
## 3:       2   2 1992-01-06 1992-01-20      sick</code></pre>
</div>
</div>
<div id="risksetmatch" class="section level1">
<h1>riskSetMatch</h1>
<p>There are multiple good programs to perform simple matching, but few for nested case-control studies where cases and controls are selected from the sample population and an additional requirement of controls to have a particular status (no event yet / alive) at the time where the case has an event/exposure. There are two main uses: Incidence density sampling, where controls are selected for each case at the time of outcome and where the controls should not (yet) have an event. Exposure density sampling is where cases are selected at the time of exposure and controls at that time should not (yet) be exposed.</p>
<p>The riskSetMatch function performs exact matching on fixed variables such as sex and age (time of birth). Variables such a time of birth needs to be rounded appropriately to ensure matches. The function can also include a list of time dependent covariates where the requirement in matching is that the date of the covariate should be prior to matching date for both or later/missing for both.</p>
<p>The function can with input be set to reuse controls or not and to use cases as controls prior to the case date or not. In general it i recommended to allow reuse of controls and to reuse cases prior to being a control. A review of biases is found in Robins: Biometrics, Vol. 42, No. 2 (Jun., 1986), 293-299</p>
<p>The riskSetMatch function is designed for very large data and uses a simplified search for controls for each case. Lists of cases and controls are constructed - and then the controls are sorted by a random variables. Next for each case controls are selected consecutively when they fit the matching conditions.</p>
<div id="usage-1" class="section level2">
<h2>Usage</h2>
<pre><code>riskSetMatch(ptid,event,terms,dat,Ncontrols,oldevent=&quot;oldevent&quot;
,caseid=&quot;caseid&quot;,reuseCases=FALSE,reuseControls=FALSE,caseIndex=NULL 
,controlIndex=NULL,NoIndex=FALSE,cores=1,dateterms=NULL)</code></pre>
<p>Author: Christian Torp-Pedersen</p>
<ul>
<li>ptid Personal ID variable defining participant</li>
<li>event Defining cases/controls MUST be integer 0/1 - 0 for controls, 1 for case</li>
<li>terms c(…..) Specifies the variables that should be matched by - enclosed in “..”</li>
<li>dat The single dataset with all information - coerced to data.table if data.frame</li>
<li>Ncontrols Number of controls sought for each case</li>
<li>oldevent Holds original value of event - distinguishes cases used as controls</li>
<li>caseid Character. Variable holding grouping variable for cases/controls (=case-ptid)</li>
<li>reuseCases Logical. If  a case can be a control prior to being a case</li>
<li>reuseControls Logical. If  a control can be reused for several cases</li>
<li>caseIndex Integer/Date. Date variable defining the date where a case becomes a case. For a case control study this is the date of event of interest, for a cohort study the date where a case enters an analysis.</li>
<li>controlIndex Integer/Date. date variable defining the date from which a controls can no longer be selected. The controlIndex must be larger than the caseIndex. For a case control study this would be the date where a control has the event of interest or is censored. For a cohort study it would be the date where the control disappears from the analysis, e.g. due to death or censoring.</li>
<li>NoIndex Logical. If  caseIndex/controlIndex are ignored</li>
<li>cores number of cores to use, default is one</li>
<li>dateterms c(….) A list of variable neames (character) in “dat” specifying dates of conditions. When a list is specified it is not only checked that the caseIndex is not after controlIndex, but also that for all variables in the list either both control/case dates are missing, both prior to case index, both after case index - or missing for case and with control date after case index.</li>
</ul>
</div>
<div id="details" class="section level2">
<h2>Details</h2>
<p>The function does exact matching and keeps 2 dates (indices) apart such that the date for controls is larger than that for cases. Because the matching is exact all matching variables must be integer or character. Make sure that sufficient rounding is done on continuous and semicontinuous variables to ensure a decent number of controls for each case. For example it may be difficult to find controls for cases of very high age and age should therefore often be rounded by 2,3 or 5 years - and extreme ages further aggregated.</p>
<p>For case control studies age may be a relevant matching parameter - for most cohort studies year of birth is more relevant since the age of a control varies with time.</p>
<p>Many datasets have comorbidities as time dependent variables. Matching on these requires that the comorbidity date is not (yet) reached for a corres- ponding variables for cases if the case does not have the comorbidity and similarly that the date has been reached when the case does have that co- morbidity.</p>
<p>For many purposes controls should be reused and cases allowed to be controls prior to being cases. By default, there is no reuse and this can be adjusted with “reuseCases” and “reuseControls”</p>
<p>The function can be used for standard matching without the caseIndex/ controlIndex (with “NoIndex”), but other packages such as MatchIt are more likely to be more optimal for these cases.</p>
<p>It may appear tempting always to use multiple cores, but this comes with a costly overhead because the function machinery has to be distributed to each defined “worker”. With very large numbers of cases and controls, multiple cores can save substantial amounts of time. When a single core is used a progress shows progress of matching. There is no progress bar with multiple cores</p>
<p>The function matchReport may afterwards be used to provide simple summaries of use of cases and controls</p>
</div>
<div id="return-1" class="section level2">
<h2>Return</h2>
<p>data.table with cases and controls. After matching, a new variable “caseid” links controls to cases. Further, a variable “oldevent” holds the orginal value of “event” - to be used to identify cases functioning as controls prior to being cases.</p>
<p>Variables in the original dataset are preserved. The final dataset includes all original cases but only the controls that were selected.</p>
<p>If cases without controls should be removed, this is done by setting the variable removeNoControls to TRUE</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Example
 <span class="kw">library</span>(data.table)
 <span class="kw">library</span>(heaven)
 case &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">40</span>),<span class="kw">rep</span>(<span class="dv">1</span>,<span class="dv">15</span>)) 
 ptid &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;P&quot;</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">55</span>)
 sex &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="st">&quot;fem&quot;</span>,<span class="dv">20</span>),<span class="kw">rep</span>(<span class="st">&quot;mal&quot;</span>,<span class="dv">20</span>),<span class="kw">rep</span>(<span class="st">&quot;fem&quot;</span>,<span class="dv">8</span>),<span class="kw">rep</span>(<span class="st">&quot;mal&quot;</span>,<span class="dv">7</span>))
 byear &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">2020</span>,<span class="dv">2030</span>),<span class="dv">20</span>),<span class="kw">rep</span>(<span class="dv">2020</span>,<span class="dv">7</span>),<span class="kw">rep</span>(<span class="dv">2030</span>,<span class="dv">8</span>))
 case.Index &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">seq</span>(<span class="dv">1</span>,<span class="dv">40</span>,<span class="dv">1</span>),<span class="kw">seq</span>(<span class="dv">5</span>,<span class="dv">47</span>,<span class="dv">3</span>))
 control.Index &lt;-<span class="st"> </span>case.Index
 diabetes &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">2</span>,<span class="dv">110</span>,<span class="dv">2</span>)
 heartdis &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">110</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">2</span>)
 diabetes &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>,<span class="dv">55</span>))
 heartdis &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">100</span>,<span class="dv">55</span>))
 dat &lt;-<span class="st"> </span><span class="kw">data.table</span>(case,ptid,sex,byear,diabetes,heartdis,case.Index,control.Index)
 <span class="co"># Very simple match without reuse - no dates to control for</span>
 out &lt;-<span class="st"> </span><span class="kw">riskSetMatch</span>(<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;case&quot;</span>,<span class="kw">c</span>(<span class="st">&quot;byear&quot;</span>,<span class="st">&quot;sex&quot;</span>),dat,<span class="dv">2</span>,<span class="dt">NoIndex=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Warning in riskSetMatch(&quot;ptid&quot;, &quot;case&quot;, c(&quot;byear&quot;, &quot;sex&quot;), dat, 2, NoIndex
## = TRUE): Defaults for reuseCases and reuseControls have changed from FALSE
## to TRUE as of 13.1.19</code></pre>
<pre><code>## ===========================================================================</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">head</span>(out,<span class="dv">10</span>)</code></pre></div>
<pre><code>##     caseid case ptid sex byear diabetes heartdis case.Index control.Index
##  1:     41    0   P1 fem  2020        1      100          1             1
##  2:     41    0  P42 fem  2020        1      100          8             8
##  3:     41    1  P41 fem  2020        1      100          5             5
##  4:     42    0  P15 fem  2020        1      100         15            15
##  5:     42    0  P19 fem  2020        1      100         19            19
##  6:     42    1  P42 fem  2020        1      100          8             8
##  7:     43    0   P9 fem  2020        1      100          9             9
##  8:     43    0  P13 fem  2020        1      100         13            13
##  9:     43    1  P43 fem  2020        1      100         11            11
## 10:     44    0   P5 fem  2020        1      100          5             5
##     oldevent
##  1:        0
##  2:        1
##  3:        1
##  4:        0
##  5:        0
##  6:        1
##  7:        0
##  8:        0
##  9:        1
## 10:        0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co"># Risk set matching without reusing cases/controls - </span>
 <span class="co"># Some cases have no controls</span>
 out2 &lt;-<span class="st"> </span><span class="kw">riskSetMatch</span>(<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;case&quot;</span>,<span class="kw">c</span>(<span class="st">&quot;byear&quot;</span>,<span class="st">&quot;sex&quot;</span>),dat,<span class="dv">2</span>,<span class="dt">caseIndex=</span><span class="st">&quot;case.Index&quot;</span>,
   <span class="dt">controlIndex=</span><span class="st">&quot;control.Index&quot;</span>)</code></pre></div>
<pre><code>## Warning in riskSetMatch(&quot;ptid&quot;, &quot;case&quot;, c(&quot;byear&quot;, &quot;sex&quot;), dat, 2,
## caseIndex = &quot;case.Index&quot;, : Defaults for reuseCases and reuseControls have
## changed from FALSE to TRUE as of 13.1.19</code></pre>
<pre><code>## ===========================================================================</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">head</span>(out2,<span class="dv">10</span>) </code></pre></div>
<pre><code>##     caseid case ptid sex byear diabetes heartdis case.Index control.Index
##  1:     41    0  P15 fem  2020        1      100          5            15
##  2:     41    0  P42 fem  2020        1      100          5             8
##  3:     41    1  P41 fem  2020        1      100          5             5
##  4:     42    0  P13 fem  2020        1      100          8            13
##  5:     42    0  P19 fem  2020        1      100          8            19
##  6:     42    1  P42 fem  2020        1      100          8             8
##  7:     43    0  P17 fem  2020        1      100         11            17
##  8:     43    0  P47 fem  2020        1      100         11            23
##  9:     43    1  P43 fem  2020        1      100         11            11
## 10:     44    0  P45 fem  2020        1      100         14            17
##     oldevent
##  1:        0
##  2:        1
##  3:        1
##  4:        0
##  5:        0
##  6:        1
##  7:        0
##  8:        1
##  9:        1
## 10:        1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co"># Risk set matching with reuse of cases (control prior to case) and reuse of </span>
 <span class="co"># controls - more cases get controls</span>
 out3 &lt;-<span class="st"> </span><span class="kw">riskSetMatch</span>(<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;case&quot;</span>,<span class="kw">c</span>(<span class="st">&quot;byear&quot;</span>,<span class="st">&quot;sex&quot;</span>),dat,<span class="dv">2</span>,<span class="dt">caseIndex=</span>
   <span class="st">&quot;case.Index&quot;</span>,<span class="dt">controlIndex=</span><span class="st">&quot;control.Index&quot;</span>
   ,<span class="dt">reuseCases=</span><span class="ot">TRUE</span>,<span class="dt">reuseControls=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Warning in riskSetMatch(&quot;ptid&quot;, &quot;case&quot;, c(&quot;byear&quot;, &quot;sex&quot;), dat, 2,
## caseIndex = &quot;case.Index&quot;, : Defaults for reuseCases and reuseControls have
## changed from FALSE to TRUE as of 13.1.19</code></pre>
<pre><code>## ===========================================================================</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">head</span>(out3,<span class="dv">10</span>)  </code></pre></div>
<pre><code>##     caseid case ptid sex byear diabetes heartdis case.Index control.Index
##  1:     41    0  P15 fem  2020        1      100          5            15
##  2:     41    0  P42 fem  2020        1      100          5             8
##  3:     41    1  P41 fem  2020        1      100          5             5
##  4:     42    0  P13 fem  2020        1      100          8            13
##  5:     42    0  P19 fem  2020        1      100          8            19
##  6:     42    1  P42 fem  2020        1      100          8             8
##  7:     43    0  P17 fem  2020        1      100         11            17
##  8:     43    0  P47 fem  2020        1      100         11            23
##  9:     43    1  P43 fem  2020        1      100         11            11
## 10:     44    0  P45 fem  2020        1      100         14            17
##     oldevent
##  1:        0
##  2:        1
##  3:        1
##  4:        0
##  5:        0
##  6:        1
##  7:        0
##  8:        1
##  9:        1
## 10:        1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co"># Same with 2 cores</span>
 out4 &lt;-<span class="st"> </span><span class="kw">riskSetMatch</span>(<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;case&quot;</span>,<span class="kw">c</span>(<span class="st">&quot;byear&quot;</span>,<span class="st">&quot;sex&quot;</span>),dat,<span class="dv">2</span>,<span class="dt">caseIndex=</span>
   <span class="st">&quot;case.Index&quot;</span>,<span class="dt">controlIndex=</span><span class="st">&quot;control.Index&quot;</span>
   ,<span class="dt">reuseCases=</span><span class="ot">TRUE</span>,<span class="dt">reuseControls=</span><span class="ot">TRUE</span>,<span class="dt">cores=</span><span class="dv">2</span>)  </code></pre></div>
<pre><code>## Warning in riskSetMatch(&quot;ptid&quot;, &quot;case&quot;, c(&quot;byear&quot;, &quot;sex&quot;), dat, 2,
## caseIndex = &quot;case.Index&quot;, : Defaults for reuseCases and reuseControls have
## changed from FALSE to TRUE as of 13.1.19</code></pre>
<pre><code>## Warning: executing %dopar% sequentially: no parallel backend registered</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">head</span>(out4,<span class="dv">10</span>)   </code></pre></div>
<pre><code>##     caseid case ptid sex byear diabetes heartdis case.Index control.Index
##  1:     41    0  P15 fem  2020        1      100          5            15
##  2:     41    0  P42 fem  2020        1      100          5             8
##  3:     41    1  P41 fem  2020        1      100          5             5
##  4:     42    0  P13 fem  2020        1      100          8            13
##  5:     42    0  P19 fem  2020        1      100          8            19
##  6:     42    1  P42 fem  2020        1      100          8             8
##  7:     43    0  P17 fem  2020        1      100         11            17
##  8:     43    0  P47 fem  2020        1      100         11            23
##  9:     43    1  P43 fem  2020        1      100         11            11
## 10:     44    0  P45 fem  2020        1      100         14            17
##     oldevent
##  1:        0
##  2:        1
##  3:        1
##  4:        0
##  5:        0
##  6:        1
##  7:        0
##  8:        1
##  9:        1
## 10:        1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co">#Time dependent matching. In addtion to fixed matching parameters there are</span>
 <span class="co">#two other sets of dates where it is required that if a case has that condi-</span>
 <span class="co">#tion prior to index, then controls also need to have the condition prior to</span>
 <span class="co">#the case index to be eligible - and if the control does not have the condi-</span>
 <span class="co">#tion prior to index then the same is required for the control.</span>
 out5 &lt;-<span class="st"> </span><span class="kw">riskSetMatch</span>(<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;case&quot;</span>,<span class="kw">c</span>(<span class="st">&quot;byear&quot;</span>,<span class="st">&quot;sex&quot;</span>),dat,<span class="dv">2</span>,<span class="dt">caseIndex=</span>
   <span class="st">&quot;case.Index&quot;</span>,<span class="dt">controlIndex=</span><span class="st">&quot;control.Index&quot;</span>
   ,<span class="dt">reuseCases=</span><span class="ot">TRUE</span>,<span class="dt">reuseControls=</span><span class="ot">TRUE</span>,<span class="dt">cores=</span><span class="dv">1</span>,
   <span class="dt">dateterms=</span><span class="kw">c</span>(<span class="st">&quot;diabetes&quot;</span>,<span class="st">&quot;heartdis&quot;</span>))  </code></pre></div>
<pre><code>## Warning in riskSetMatch(&quot;ptid&quot;, &quot;case&quot;, c(&quot;byear&quot;, &quot;sex&quot;), dat, 2,
## caseIndex = &quot;case.Index&quot;, : Defaults for reuseCases and reuseControls have
## changed from FALSE to TRUE as of 13.1.19</code></pre>
<pre><code>## ===========================================================================</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">head</span>(out5,<span class="dv">10</span>)</code></pre></div>
<pre><code>##     caseid case ptid sex byear diabetes heartdis case.Index control.Index
##  1:     41    0  P15 fem  2020        1      100          5            15
##  2:     41    0  P42 fem  2020        1      100          5             8
##  3:     41    1  P41 fem  2020        1      100          5             5
##  4:     42    0  P13 fem  2020        1      100          8            13
##  5:     42    0  P19 fem  2020        1      100          8            19
##  6:     42    1  P42 fem  2020        1      100          8             8
##  7:     43    0  P17 fem  2020        1      100         11            17
##  8:     43    0  P47 fem  2020        1      100         11            23
##  9:     43    1  P43 fem  2020        1      100         11            11
## 10:     44    0  P45 fem  2020        1      100         14            17
##     oldevent
##  1:        0
##  2:        1
##  3:        1
##  4:        0
##  5:        0
##  6:        1
##  7:        0
##  8:        1
##  9:        1
## 10:        1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co">#POSTPROCESSING</span>
 <span class="co">#It may be convinient to add the number of controls found to each case in or-</span>
 <span class="co">#der to remove cases without controls or where very few controls have been</span>
 <span class="co">#found.  This is easily obtained using data.table - with the example above:</span>
 <span class="co">#out5[,numControls:=.N,by=caseid] # adds a column with the number of controls</span>
                                  <span class="co"># for each case-ID   </span></code></pre></div>
</div>
</div>
<div id="matchreport" class="section level1">
<h1>matchReport</h1>
<p>This function is to be applied to the output from riskSetMatch and provides tabulation of uses and reuses of controls and cases</p>
<div id="usage-2" class="section level2">
<h2>Usage</h2>
<p>matchReport(dat, id, case, caseid,oldcase=“oldevent”) * dat - data.table with result from riskSetMatch * id - variable with participant id * case - 0=control, 1=case * caseid - variable defining the groups of matching cases/controls * oldcase - Variable holding case/control=0/1 prior to matching. Distinguishes cases reused as controls</p>
<p>Author: Christian Torp-Pedersen</p>
</div>
<div id="details-1" class="section level2">
<h2>Details</h2>
<p>This function can be helpful to define matching options. If there is excessive reuse of controls or many cases do not find controls it may be desirable to do further rounding of matching variables. Return: Three small tables - Number of controls for cases, use/reuse of controls, use/reuse of cases ## Example</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">require</span>(data.table)
 case &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">40</span>),<span class="kw">rep</span>(<span class="dv">1</span>,<span class="dv">15</span>)) 
 ptid &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;P&quot;</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">55</span>)
 sex &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="st">&quot;fem&quot;</span>,<span class="dv">20</span>),<span class="kw">rep</span>(<span class="st">&quot;mal&quot;</span>,<span class="dv">20</span>),<span class="kw">rep</span>(<span class="st">&quot;fem&quot;</span>,<span class="dv">8</span>),<span class="kw">rep</span>(<span class="st">&quot;mal&quot;</span>,<span class="dv">7</span>))
 byear &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">2020</span>,<span class="dv">2030</span>),<span class="dv">20</span>),<span class="kw">rep</span>(<span class="dv">2020</span>,<span class="dv">7</span>),<span class="kw">rep</span>(<span class="dv">2030</span>,<span class="dv">8</span>))
 caseIndex &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">seq</span>(<span class="dv">1</span>,<span class="dv">40</span>,<span class="dv">1</span>),<span class="kw">seq</span>(<span class="dv">5</span>,<span class="dv">47</span>,<span class="dv">3</span>))
 controlIndex &lt;-<span class="st"> </span>caseIndex
 <span class="kw">library</span>(data.table)
 dat &lt;-<span class="st"> </span><span class="kw">data.table</span>(ptid,case,sex,byear,caseIndex,controlIndex)
 <span class="co"># Very simple match without reuse - no dates to control for</span>
 dataout &lt;-<span class="st"> </span><span class="kw">riskSetMatch</span>(<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;case&quot;</span>,<span class="kw">c</span>(<span class="st">&quot;byear&quot;</span>,<span class="st">&quot;sex&quot;</span>),dat,<span class="dv">2</span>,<span class="dt">caseIndex=</span><span class="st">&quot;caseIndex&quot;</span>,
   <span class="dt">controlIndex=</span><span class="st">&quot;controlIndex&quot;</span>,<span class="dt">reuseCases=</span><span class="ot">TRUE</span>,<span class="dt">reuseControls=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Warning in riskSetMatch(&quot;ptid&quot;, &quot;case&quot;, c(&quot;byear&quot;, &quot;sex&quot;), dat, 2,
## caseIndex = &quot;caseIndex&quot;, : Defaults for reuseCases and reuseControls have
## changed from FALSE to TRUE as of 13.1.19</code></pre>
<pre><code>## ===========================================================================</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">matchReport</span>(dataout,<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;case&quot;</span>,<span class="st">&quot;caseid&quot;</span>)   </code></pre></div>
<pre><code>## 
##  ------------------------------------------------------------------ 
##  Matching success
##  Line 1, number of controls found - Line 2, number of occurrencescontrols
##  0  1  2 
##  3  2 10 
## 
##  ------------------------------------------------------------------
##  Reuse/use of controls 
##  Line 1, number of times - Line 2, number of occurrences 
## N
##  1  2  3 
## 12  2  2 
## 
##  ------------------------------------------------------------------
##  Use and reuse of cases as controls 
##  Line 1, number of times - Line 2, number of occurrences 
## N
## 1 2 3 4 
## 7 5 1 2 
## 
##  ------------------------------------------------------------------</code></pre>
</div>
</div>
<div id="lexis-functions" class="section level1">
<h1>Lexis functions</h1>
<p>The lexis functions are 3 functions to aid splitting of observations in order to perform time varying analyses. To understand the functionality the following graph is a lexis diagram.</p>
<!-- ![](./images/lexisdiagram.png) -->
<p>The diagram shows time passing for a number of individual by age and calender time. Some have an event (red x) and som not. For time dependent analysis individuals are split by calender time and age. The individual most to the right is split in 5 records, the split occurring each time a line is crossed. This allows regression to be time dependent with individuals contributing to different age/time periods and only be compared with other individuals in the same age/time period.</p>
<p>In practice a range of splits are performed:</p>
<ul>
<li>Comorbidities: These are most often used to split a single time, the date of the comorbidity</li>
<li>Period effects: For drug treatment, pregnancies and many other situations there are periods where individuals are in one state and other periods with other states - such a pregnancy, dose of a drug etc.</li>
<li>Sequential splits: As shown in the lexis diagram it is natural to split a number of times on age and calender time</li>
</ul>
<p>For each of the lexis functions two inputs are important:</p>
<ul>
<li>Base data - These are the data that should be split and they must contain a person-id, a starting date, and end date and a recording wheter the period ended with an event.</li>
<li>Splitting guide - This is a dataset (or vector for lexisSeq) that defines where splits should occur.</li>
</ul>
<p>The use of the 3 lexi function can be shown graphically</p>
<!-- ```{r, out.width = "400px",echo=FALSE} -->
<!-- knitr::include_graphics("./images/lexisfunctions.png") -->
<!-- ``` -->
<p>Note that the content of the Splitting guide should not be part of Base data</p>
<p>A general warning: Be careful when working with dates, not the least if the dates are provided from SAS. By default SAS has the origin of dates as 1960-01-01 and R as 1970-01-01. Confusion can easily occur. Output of dates from lexis functions is alway “integer”. This will result in dates using 1970-01-01 as origin.</p>
</div>
<div id="lexistwo" class="section level1">
<h1>lexisTwo</h1>
<p>This function can split observations on a number of conditions such as comorbidites and each defined by a date and missing if there is no comorbidity.</p>
<p>The Base date needs to include columns defining participant, start of period, end of period and event (numeric 0/1)</p>
<p>The splitting guide needs to be a matrix like data.table where the first column is patient id and the further columns each define dates where splitting should occur. Missing dates result in no splitting. For comorbidities is is useful to name the columns after the comorbidity and let the content of the columns be the dates of the comorbidity when present and missing if not present.</p>
<div id="usage-3" class="section level2">
<h2>Usage</h2>
<p>lexisTwo(indat,splitdat,invars,splitvars)</p>
<p>author Christian Torp-Pedersen</p>
<div id="base-data" class="section level3">
<h3>Base data</h3>
<p>A data.table or data.frame whose first 4 columns are in that particular order:</p>
<ul>
<li>ID - Person identification - note that there may be multiple lines per ID if previously split</li>
<li>Start of time interval. Either a date or an integer/numeric.</li>
<li>Stop - End of time interval. Either in date format or given as numeric/integer.</li>
<li>event - Binary 0-1 variable indicating if an event occurred at end of interval</li>
</ul>
</div>
</div>
<div id="splitting-guide" class="section level2">
<h2>Splitting guide</h2>
<p>A data.table which contains person specific information about the onset dates of comorbidities and other events.</p>
<ul>
<li>ID - Person ID</li>
<li>Characteristic 1 - Column of dates (integer/numeric) defining start of that characteristic</li>
<li>Characteristic 2 -</li>
<li>Further characteristic columns</li>
</ul>
</div>
<div id="return-2" class="section level2">
<h2>Return</h2>
<p>The function returns a new data table where records have been split according to the splittingguide dataset. Variables unrelated to the splitting are left unchanged. The names of columns from “splitvars” are also in output data, but now they have the value zero before the dates and 1 after.</p>
</div>
<div id="details-2" class="section level2">
<h2>Details</h2>
<p>The program checks that intervals are not negative. Violation results in an error. Overlap may occur in real data, but the user needs to make decisions regarding this prior to using this function.</p>
<p>It is required that the splittingguide contains at least one record.<br />
Missing data in the person id variables are not allowed and will cause errors.</p>
<p>The output will always have the “next” period starting on the day where the last period ended. This is to ensure that period lengths are calculated pro- perly. The program will also allow periods of zero lengths which is a conse- quence when multiple splits are made on the same day. When there is an event on a period with zero length it is important to keep that period not to loose events for calculations. Whether other zero length records should be kept in calculations depends on the context.</p>
</div>
<div id="examples" class="section level2">
<h2>Examples</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">library</span>(data.table)
 
 dat &lt;-<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">pnr=</span><span class="kw">c</span>(<span class="st">&quot;123456&quot;</span>,<span class="st">&quot;123456&quot;</span>,<span class="st">&quot;234567&quot;</span>,<span class="st">&quot;234567&quot;</span>,<span class="st">&quot;345678&quot;</span>,<span class="st">&quot;345678&quot;</span>
 ,<span class="st">&quot;456789&quot;</span>,<span class="st">&quot;456789&quot;</span>),
                 <span class="dt">start=</span><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">100</span>)),
                 <span class="dt">end=</span><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">100</span>,<span class="dv">200</span>)),
                 <span class="dt">event=</span><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)))
 split &lt;-<span class="st"> </span><span class="kw">data.table</span> (<span class="dt">pnr=</span><span class="kw">c</span>(<span class="st">&quot;123456&quot;</span>,<span class="st">&quot;234567&quot;</span>,<span class="st">&quot;345678&quot;</span>,<span class="st">&quot;456789&quot;</span>),
 <span class="dt">como1.onset=</span><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="ot">NA</span>,<span class="dv">49</span>,<span class="dv">50</span>)), <span class="dt">como2.onset=</span><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="dv">25</span>,<span class="dv">75</span>,<span class="dv">49</span>,<span class="dv">49</span>)),
 <span class="dt">como3.onset=</span><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="dv">30</span>,<span class="ot">NA</span>,<span class="dv">49</span>,<span class="dv">48</span>)), <span class="dt">como4.onset=</span><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="dv">50</span>,<span class="dv">49</span>,<span class="dv">49</span>,<span class="dv">47</span>))) 
 <span class="co">#Show the datasets:</span>
 dat[]</code></pre></div>
<pre><code>##       pnr start end event
## 1: 123456     0 100     0
## 2: 123456   100 200     1
## 3: 234567     0 100     0
## 4: 234567   100 200     0
## 5: 345678     0 100     0
## 6: 345678   100 200     1
## 7: 456789     0 100     0
## 8: 456789   100 200     1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> split[]</code></pre></div>
<pre><code>##       pnr como1.onset como2.onset como3.onset como4.onset
## 1: 123456           0          25          30          50
## 2: 234567          NA          75          NA          49
## 3: 345678          49          49          49          49
## 4: 456789          50          49          48          47</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw">lexisTwo</span>(dat <span class="co"># inddato with id/in/out/event</span>
    ,split <span class="co"># Data with id and dates</span>
    ,<span class="kw">c</span>(<span class="st">&quot;pnr&quot;</span>,<span class="st">&quot;start&quot;</span>,<span class="st">&quot;end&quot;</span>,<span class="st">&quot;event&quot;</span>) <span class="co">#names of id/in/out/event - in that order</span>
    ,<span class="kw">c</span>(<span class="st">&quot;como1.onset&quot;</span>,<span class="st">&quot;como2.onset&quot;</span>,<span class="st">&quot;como3.onset&quot;</span>,<span class="st">&quot;como4.onset&quot;</span>)) </code></pre></div>
<pre><code>##     start end event como1.onset como2.onset como3.onset como4.onset    pnr
##  1:     0  25     0           1           0           0           0 123456
##  2:    25  30     0           1           1           0           0 123456
##  3:    30  50     0           1           1           1           0 123456
##  4:    50 100     0           1           1           1           1 123456
##  5:   100 200     1           1           1           1           1 123456
##  6:     0  49     0           0           0           0           0 234567
##  7:    49  75     0           0           0           0           1 234567
##  8:    75 100     0           0           1           0           1 234567
##  9:   100 200     0           0           1           0           1 234567
## 10:     0  49     0           0           0           0           0 345678
## 11:    49 100     0           1           1           1           1 345678
## 12:   100 200     1           1           1           1           1 345678
## 13:     0  47     0           0           0           0           0 456789
## 14:    47  48     0           0           0           0           1 456789
## 15:    48  49     0           0           0           1           1 456789
## 16:    49  50     0           0           1           1           1 456789
## 17:    50 100     0           1           1           1           1 456789
## 18:   100 200     1           1           1           1           1 456789</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    <span class="co">#Names of date-vars to split by</span></code></pre></div>
</div>
</div>
<div id="lexisfromto" class="section level1">
<h1>LexisFromTo</h1>
<p>This function handles situations where individuals have conditions that are limited in time - pregnancy, drug doses etc. Each limited condition has a starting date, an end date, the condition as a character string and a name defining the condition. Multiple limited conditions can be in a single data.table.</p>
<div id="base-data-1" class="section level2">
<h2>Base data</h2>
<p>A data.table or data.frame whose first 4 columns are in that particular order:</p>
<ul>
<li>ID - Person identification - note that there may be multiple lines per ID if previously split</li>
<li>Start of time interval. Either a date or an integer/numeric.</li>
<li>Stop - End of time interval. Either in date format or given as numeric/integer.</li>
<li>event - Binary 0-1 variable indicating if an event occurred at end of interval</li>
</ul>
</div>
<div id="splitting-guide-1" class="section level2">
<h2>Splitting guide</h2>
<ul>
<li>ID - person id</li>
<li>start - date/integer to set start of period</li>
<li>end - date/ineger to set end of period</li>
<li>value - character variable indicating condition (dose of drug, pregnancy etc)</li>
<li>name - name of condition (pregnancy, occupation, name of drug etc)</li>
</ul>
</div>
<div id="usage-4" class="section level2">
<h2>Usage</h2>
<p>lexisFromTo(indat,splitdat,invars,splitvars) author: Christian Torp-Pedersen</p>
<ul>
<li>indat - base data with id, start, end, event and other data - possibly already split</li>
<li>splitdat - Data with splitting guide - id/from/to/value/name</li>
<li>invars - vector of colum names for id/entry/exit/event - in that order, example: c(“id”,“start”,“end”,“event”)</li>
<li>splitvars - vector of column names containing dates to split by. example: c(“id”,“start”,“end”,“value”,“name”) - must be in that order!</li>
</ul>
</div>
<div id="return-3" class="section level2">
<h2>Return</h2>
<p>The function returns a new data table where records have been split according to the splitting guide dataset. Variables unrelated to the splitting are left unchanged.</p>
</div>
<div id="details-3" class="section level2">
<h2>Details</h2>
<p>The input to this function are two data.tables and two lists of the critical variables. The BASE data it the data to be split. This data must have a variable to identify participants, start/end times and a variable to indicate event after last interval. The other table (SPLITTINGUIDE) contains possibly multiple records for each participants with id/from/to/value/name.</p>
<p>The program checks that intervals are not negative and that intervals for each “name” and each individual do not overlap. Violation stops the program with error. Overlaps may occur in real situations, but the user needs to make decisions regarding this prior to this function.</p>
<p>It is required that the splittingguide contains at least one record. Missing data for key variables are not allowed and will cause errors.</p>
</div>
<div id="examples-1" class="section level2">
<h2>Examples</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(data.table)
dat &lt;-<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">id=</span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>,<span class="st">&quot;D&quot;</span>),
                 <span class="dt">start=</span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">400</span>),<span class="dt">origin=</span><span class="st">'1970-01-01'</span>),
                 <span class="dt">end=</span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">300</span>,<span class="dv">500</span>),<span class="dt">origin=</span><span class="st">'1970-01-01'</span>),
                 <span class="dt">event=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>))
split &lt;-<span class="st"> </span><span class="kw">data.table</span> (<span class="dt">id=</span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;D&quot;</span>,<span class="st">&quot;D&quot;</span>),
                    <span class="dt">start=</span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">50</span>,<span class="dv">25</span>,<span class="dv">150</span>,<span class="dv">110</span>,<span class="dv">150</span>,<span class="dv">400</span>,<span class="dv">300</span>,<span class="dv">500</span>),<span class="dt">origin=</span><span class="st">'1970-01-01'</span>),
                    <span class="dt">end=</span> <span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="dv">25</span>,<span class="dv">75</span>,<span class="dv">150</span>,<span class="dv">151</span>,<span class="dv">120</span>,<span class="dv">250</span>,<span class="dv">500</span>,<span class="dv">400</span>,<span class="dv">500</span>),<span class="dt">origin=</span><span class="st">'1970-01-01'</span>),
                    <span class="dt">value=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">7</span>),
                    <span class="dt">name=</span><span class="kw">c</span>(<span class="st">&quot;d1&quot;</span>,<span class="st">&quot;d1&quot;</span>,<span class="st">&quot;d2&quot;</span>,<span class="st">&quot;d2&quot;</span>,<span class="st">&quot;d1&quot;</span>,<span class="st">&quot;d1&quot;</span>,<span class="st">&quot;d2&quot;</span>,<span class="st">&quot;d3&quot;</span>,<span class="st">&quot;d4&quot;</span>))
<span class="co">#Show the dataset:</span>
dat[]</code></pre></div>
<pre><code>##    id      start        end event
## 1:  A 1970-01-01 1970-04-11     0
## 2:  A 1970-04-11 1970-07-20     1
## 3:  B 1970-01-01 1970-04-11     0
## 4:  B 1970-04-11 1970-07-20     0
## 5:  C 1970-07-20 1970-10-28     1
## 6:  D 1971-02-05 1971-05-16     1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">split[]                   </code></pre></div>
<pre><code>##    id      start        end value name
## 1:  A 1970-01-01 1970-01-26     1   d1
## 2:  A 1970-02-20 1970-03-17     2   d1
## 3:  A 1970-01-26 1970-05-31     3   d2
## 4:  A 1970-05-31 1970-06-01     4   d2
## 5:  B 1970-04-21 1970-05-01     1   d1
## 6:  B 1970-05-31 1970-09-08     2   d1
## 7:  B 1971-02-05 1971-05-16     3   d2
## 8:  D 1970-10-28 1971-02-05     6   d3
## 9:  D 1971-05-16 1971-05-16     7   d4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">temp &lt;-<span class="st"> </span><span class="kw">lexisFromTo</span>(dat <span class="co"># inddato with id/in/out/event</span>
                   ,split <span class="co"># Data with id and dates</span>
                   ,<span class="kw">c</span>(<span class="st">&quot;id&quot;</span>,<span class="st">&quot;start&quot;</span>,<span class="st">&quot;end&quot;</span>,<span class="st">&quot;event&quot;</span>) <span class="co">#names of id/in/out/event - in that order</span>
                  ,<span class="kw">c</span>(<span class="st">&quot;id&quot;</span>,<span class="st">&quot;start&quot;</span>,<span class="st">&quot;end&quot;</span>,<span class="st">&quot;value&quot;</span>,<span class="st">&quot;name&quot;</span>)) <span class="co">#Nmes var date-vars to split by</span>
temp[]</code></pre></div>
<pre><code>##     start end event d1 d2 d3 d4 id
##  1:     0  25     0  1           A
##  2:    25  50     0     3        A
##  3:    50  75     0  2  3        A
##  4:    75 100     0     3        A
##  5:   100 150     0     3        A
##  6:   150 151     0     4        A
##  7:   151 200     1              A
##  8:     0 100     0              B
##  9:   100 110     0              B
## 10:   110 120     0  1           B
## 11:   120 150     0              B
## 12:   150 200     0  2           B
## 13:   200 300     1              C
## 14:   400 500     0              D
## 15:   500 500     1           7  D</code></pre>
</div>
</div>
<div id="lexisseq" class="section level1">
<h1>LexisSeq</h1>
<p>The base data for this function is identical to the other lexis functions, a data.table including c(“id”,“start”,“end”,“event”) - and other variables to be preserved during splitting. In contrast to the other functions the splitting guide is not a data.table but a vector of dates. It can be specified as a fixed vector with selected dates or in a “seq” format (from,to,by). This simple vector is useful for splitting according to calender time where splitting is identical for all subjects. Further a “varname” may hold a variable from the base data to be added to the vector. This is typically birthdate for splitting on age - and it may be time of exposure when splitting in periods after exposure.</p>
<div id="usage-5" class="section level2">
<h2>Usage</h2>
<p>lexisSeq(indat,invars,varname=NULL,splitvector,format,value=“value”)</p>
<p>Author: Christian Torp-Pedersen</p>
<ul>
<li>indat - base data with id, start, end, event and other data - possibly already split</li>
<li>invars - vector of colum names for id/entry/exit/event - in that order, example: c(“id”,“start”,“end”,“event”)</li>
<li>varname - name of variable to be added to vector</li>
<li>splitvector - A vector of calender times (integer). Splitvector can be a sequence of fixed times with format=“vector” or generate a sequence of from-to-by if given 3 values and format=“seq”</li>
<li>format - either “vector” for fixed times or “seq” to generate a sequence of from-to-by</li>
<li>value - 0 to the left of the vector, increase of 1 as each element of vector is passed</li>
</ul>
</div>
<div id="return-4" class="section level2">
<h2>Return</h2>
<p>The function returns a new data table where records have been split according to the provided vector. Variables unrelated to the splitting are left unchanged.</p>
</div>
<div id="details-4" class="section level2">
<h2>Details</h2>
<p>The input must be data.table. This data.table is assumed already to be split by other functions with multiple records having identical participant id. The function extracts those variables necessary for splitting, splits by the provided vector and finally merges other variable onto the final result.</p>
<p>The output will always have the “next” period starting on the day where the last period ended. This is to ensure that period lengths are calculated pro- perly. The program will also allow periods of zero lengths which is a conse- quence when multiple splits are made on the same day. When there is an event on a period with zero length it is important to keep that period not to loose events for calculations. Whether other zero length records should be kept in calculations depend on context.</p>
</div>
<div id="examples-2" class="section level2">
<h2>Examples</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(data.table)
dat &lt;-<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">ptid=</span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>,<span class="st">&quot;C&quot;</span>,<span class="st">&quot;D&quot;</span>,<span class="st">&quot;D&quot;</span>),
                <span class="dt">start=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">100</span>),
                <span class="dt">end=</span><span class="kw">c</span>(<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">100</span>,<span class="dv">200</span>),
                <span class="dt">dead=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>),
                <span class="dt">Bdate=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">5000</span>,<span class="op">-</span><span class="dv">5000</span>,<span class="op">-</span><span class="dv">2000</span>,<span class="op">-</span><span class="dv">2000</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">100</span>,<span class="dv">100</span>))
<span class="co">#Example 1 - Splitting on a vector with 3 values to be added to &quot;Bdate&quot;                 </span>
out &lt;-<span class="st"> </span><span class="kw">lexisSeq</span>(<span class="dt">indat=</span>dat,<span class="dt">invars=</span><span class="kw">c</span>(<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;start&quot;</span>,<span class="st">&quot;end&quot;</span>,<span class="st">&quot;dead&quot;</span>),
               <span class="dt">varname=</span><span class="st">&quot;Bdate&quot;</span>,<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">150</span>,<span class="dv">5000</span>),<span class="dt">format=</span><span class="st">&quot;vector&quot;</span>)
out[]</code></pre></div>
<pre><code>##    start end dead value ptid Bdate
## 1:    NA  NA   NA    NA    A -5000
## 2:   100 200    1     3    A -5000
## 3:     0 100    0     2    B -2000
## 4:   100 200    0     2    B -2000
## 5:     0 100    0     1    C     0
## 6:   100 150    0     1    C     0
## 7:   150 200    1     2    C     0
## 8:     0 100    0     0    D   100
## 9:   100 200    1     1    D   100</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Example 2 - splitting on a from-to-by vector with no adding (calender time?)</span>
out2 &lt;-<span class="st"> </span><span class="kw">lexisSeq</span>(<span class="dt">indat=</span>dat,<span class="dt">invars=</span><span class="kw">c</span>(<span class="st">&quot;ptid&quot;</span>,<span class="st">&quot;start&quot;</span>,<span class="st">&quot;end&quot;</span>,<span class="st">&quot;dead&quot;</span>),
                 <span class="dt">varname=</span><span class="ot">NULL</span>,<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">200</span>,<span class="dv">50</span>),<span class="dt">format=</span><span class="st">&quot;seq&quot;</span>,<span class="dt">value=</span><span class="st">&quot;myvalue&quot;</span>)
out2[]</code></pre></div>
<pre><code>##     start end dead myvalue ptid Bdate
##  1:     0  50    0       1    A -5000
##  2:    50 100    0       2    A -5000
##  3:   100 150    0       3    A -5000
##  4:   150 200    1       4    A -5000
##  5:     0  50    0       1    B -2000
##  6:    50 100    0       2    B -2000
##  7:   100 150    0       3    B -2000
##  8:   150 200    0       4    B -2000
##  9:     0  50    0       1    C     0
## 10:    50 100    0       2    C     0
## 11:   100 150    0       3    C     0
## 12:   150 200    1       4    C     0
## 13:     0  50    0       1    D   100
## 14:    50 100    0       2    D   100
## 15:   100 150    0       3    D   100
## 16:   150 200    1       4    D   100</code></pre>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
